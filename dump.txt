
{- -}
--strLit : SnocList Char -> JSToken
--strLit = Lit . JString . cast
{-
str : SnocList Char -> AutoTok e JSToken
str sc ('\\' :: c  :: xs) = case c of
  '"'  => str (sc :< '"') xs
  'n'  => str (sc :< '\n') xs
  'f'  => str (sc :< '\f') xs
  'b'  => str (sc :< '\b') xs
  'r'  => str (sc :< '\r') xs
  't'  => str (sc :< '\t') xs
  '\\' => str (sc :< '\\') xs
  '/'  => str (sc :< '/') xs
  'u'  => case xs of
    w :: x :: y :: z :: t' =>
      if isHexDigit w && isHexDigit x && isHexDigit y && isHexDigit z
        then
          let c := cast $ hexDigit w * 0x1000 +
                          hexDigit x * 0x100 +
                          hexDigit y * 0x10 +
                          hexDigit z 
           in str (sc :< c) t'
        else invalidEscape p t'
    _    => invalidEscape p xs
  _    => invalidEscape p (c::xs)
str sc ('"'  :: xs) = Succ (strLit sc) xs
str sc (c    :: xs) =
  if isControl c then range (InvalidControl c) p xs
  else str (sc :< c) xs
str sc []           = eoiAt p



-- A shifter that moves digits.
digs : AutoShift False
digs (x :: xs) = if isDigit x then digs xs else Succ (x::xs)
digs []        = Succ []

-- A strict version of `digs`.
digs1 : AutoShift True
digs1 (x :: xs) = if isDigit x then digs xs else unknownRange sh xs
digs1 []        = eoiAt sh

-- A shifter that moves an integer prefix
integer : AutoShift True
integer ('-' :: xs) = digs1 {b} xs
integer ('+' :: xs) = digs1 {b} xs
integer xs          = digs1 {b} xs

dot,rest,digs0,exp : AutoShift False
exp ('e' :: xs) = weakens $ integer {b} xs
exp ('E' :: xs) = weakens $ integer {b} xs
exp xs          = Succ xs

dot (x :: xs) = if isDigit x then dot xs else exp (x::xs)
dot []        = Succ []

rest ('.'::x::xs) = if isDigit x then dot xs else failDigit Dec (shift sh)
rest ('.'::[])    = eoiAt (shift sh)
rest xs           = exp xs

digs0 (x :: xs) = if isDigit x then digs0 xs else rest (x::xs)
digs0 []        = Succ []

-- A shifter for recognizing JSON numbers
num : Shifter True
num sc ('-' :: '0' :: xs) = rest xs
num sc ('-' :: x   :: xs) =
  if isDigit x then digs0 xs else failDigit Dec (shift Same)
num sc ('0'        :: xs) = rest xs
num sc (x          :: xs) = if isDigit x then digs0 xs else failDigit Dec Same
num sc []                 = eoiAt Same

dbl : Tok True e JSToken
dbl cs = suffix (Lit . JNumber . cast . cast {to = String}) $ num [<] cs


tok : Tok True e JSToken
tok (','::xs)                    = Succ ',' xs
tok ('"'::xs)                    = str [<] xs
tok (':'::xs)                    = Succ ':' xs
tok ('['::xs)                    = Succ '[' xs
tok (']'::xs)                    = Succ ']' xs
tok ('{'::xs)                    = Succ '{' xs
tok ('}'::xs)                    = Succ '}' xs
tok ('n':: 'u'::'l'::'l'::t)     = Succ (Lit JNull) t
tok ('t'::'r'::'u'::'e'::t)      = Succ (Lit $ JBool True) t
tok ('f'::'a'::'l'::'s'::'e'::t) = Succ (Lit $ JBool False) t
tok xs                           = dbl xs

tokJSON :
     String
  -> Either (Bounded $ ParseError Void Void) (List $ Bounded JSToken)
tokJSON = singleLineDropSpaces tok

tokJSON :
     String
  -> Either (Bounded $ ParseError Void Void) (List $ Bounded JSToken)

numberLit : Lexer
numberLit
  = let sign  = is '-'
        whole = is '0' <|> range '1' '9' <+> many digit
        frac  = is '.' <+> digits
        exp   = like 'e' <+> opt (oneOf ['+','-']) <+> digits in
        opt sign <+> whole <+> opt frac <+> opt exp

jsstring : Lexer
jsstring = quote (is '"') jsonChar
  where
    jsonChar : Lexer
    jsonChar =
          (is '\\' <+> oneOf ['\\','"','n','f','b','r','t','/'])
      <|> (exact "\\u" <+> exactly 4 (pred isHexDigit))
      <|> non (pred isControl <|> is '"' <|> is '\\')
 
jsonTokenMap : TokenMap JSToken
jsonTokenMap =
  [ (spaces, const Space)
  , (is ',', const ',')
  , (is ':', const ':')
  , (is '[', const '[')
  , (is ']', const ']')
  , (is '{', const '{')
  , (is '}', const '}')
  , (exact "null", const $ Lit JNull)
  , (exact "true", const $ Lit (JBool True))
  , (exact "false", const $ Lit (JBool False))
  , (numberLit, Lit . JNumber . cast . cast {to = String})
  , (jsstring, Lit . JString . cast)
  ]

tokJSON2 :
     String
  -> Either (Bounded $ ParseError Void Void) (List $ Bounded JSToken)
tokJSON2 = lexManual (first jsonTokenMap)



0 Rule : Bool -> Type -> Type
Rule b t =
     (xs : List $ Bounded JSToken)
  -> (0 acc : SuffixAcc xs)
  -> Res b JSToken xs JSErr t

array : Bounds -> SnocList JsonTree -> Rule True JsonTree

object : Bounds -> SnocList (String,JsonTree) -> Rule True JsonTree

 
value : Rule True JsonTree
value (B (Lit y) _ :: xs)        _      = Succ0 y xs
value (B '[' _ :: B ']' _ :: xs) _      = Succ0 (JArray []) xs
value (B '[' b :: xs)            (SA r) = succT $ array b [<] xs r
value (B '{' _ :: B '}' _ :: xs) _      = Succ0 (JObject []) xs
value (B '{' b :: xs)            (SA r) = succT $ object b [<] xs r
value xs                         _      = fail xs

array b sv xs sa@(SA r) = case value xs sa of
  Succ0 v (B ',' _ :: ys) => succT $ array b (sv :< v) ys r
  Succ0 v (B ']' _ :: ys) => Succ0 (JArray $ sv <>> [v]) ys
  res                     => failInParen b '[' res

object b sv (B (Lit $ JString l) _ :: B ':' _ :: xs) (SA r) =
  case succT $ value xs r of
    Succ0 v (B ',' _ :: ys) => succT $ object b (sv :< (l,v)) ys r
    Succ0 v (B '}' _ :: ys) => Succ0 (JObject $ sv <>> [(l,v)]) ys
    res                     => failInParen b '{' res
object b sv (B (Lit $ JString _) _ :: x :: xs) _ = expected x.bounds ':'
object b sv (x :: xs)                          _ = custom x.bounds ExpectedString
object b sv []                                 _ = eoi
-}
