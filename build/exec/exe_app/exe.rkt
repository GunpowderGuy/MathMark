#lang racket/base
;; @generated by Idris 0.6.0-870bc8243, Racket backend
(require racket/async-channel)         ; for asynchronous channels
(require racket/future)                ; for parallelism/concurrency
(require racket/math)                  ; for math ops
(require racket/system)                ; for system
(require racket/unsafe/ops)            ; for fast fixnum ops
(require rnrs/bytevectors-6)           ; for buffers
(require rnrs/io/ports-6)              ; for files
(require srfi/19)                      ; for file handling and data
(require ffi/unsafe ffi/unsafe/define) ; for calling C

(require racket/flonum)                ; for float-typed transcendental functions
(define-ffi-definer define-libidris2_support (ffi-lib "libidris2_support" ))
(define-libidris2_support idris2_putStr (_fun _string/utf-8 -> _void))

(let ()
(define (blodwen-os)
  (case (system-type 'os)
    [(unix) "unix"]
    [(macosx) "darwin"]
    [(windows) "windows"]
    [else "unknown"]))

(define blodwen-lazy
  (lambda (f)
    (let ([evaluated #f] [res void])
      (lambda ()
        (if (not evaluated)
            (begin (set! evaluated #t)
                   (set! res (f))
                   (set! f void))
            (void))
        res))))

(define (blodwen-toSignedInt x bits)
  (if (bitwise-bit-set? x bits)
      (bitwise-ior x (arithmetic-shift (- 1) bits))
      (bitwise-and x (sub1 (arithmetic-shift 1 bits)))))

(define (blodwen-toUnsignedInt x bits)
  (bitwise-and x (sub1 (arithmetic-shift 1 bits))))

(define (blodwen-euclidDiv a b)
  (let ((q (quotient a b))
        (r (remainder a b)))
    (if (< r 0)
      (if (> b 0) (- q 1) (+ q 1))
      q)))

(define (blodwen-euclidMod a b)
  (let ((r (remainder a b)))
    (if (< r 0)
      (if (> b 0) (+ r b) (- r b))
      r)))

(define bu+ (lambda (x y bits) (blodwen-toUnsignedInt (+ x y) bits)))
(define bu- (lambda (x y bits) (blodwen-toUnsignedInt (- x y) bits)))
(define bu* (lambda (x y bits) (blodwen-toUnsignedInt (* x y) bits)))
(define bu/ (lambda (x y bits) (blodwen-toUnsignedInt (quotient x y) bits)))

(define bs+ (lambda (x y bits) (blodwen-toSignedInt (+ x y) bits)))
(define bs- (lambda (x y bits) (blodwen-toSignedInt (- x y) bits)))
(define bs* (lambda (x y bits) (blodwen-toSignedInt (* x y) bits)))
(define bs/ (lambda (x y bits) (blodwen-toSignedInt (blodwen-euclidDiv x y) bits)))

; To match Chez
(define (fxadd1 x) (unsafe-fx+ x 1))
(define (fxsub1 x) (unsafe-fx- x 1))

(define (integer->bits8 x) (bitwise-and x #xff))
(define (integer->bits16 x) (bitwise-and x #xffff))
(define (integer->bits32 x) (bitwise-and x #xffffffff))
(define (integer->bits64 x) (bitwise-and x #xffffffffffffffff))

(define (bits16->bits8 x) (bitwise-and x #xff))
(define (bits32->bits8 x) (bitwise-and x #xff))
(define (bits64->bits8 x) (bitwise-and x #xff))
(define (bits32->bits16 x) (bitwise-and x #xffff))
(define (bits64->bits16 x) (bitwise-and x #xffff))
(define (bits64->bits32 x) (bitwise-and x #xffffffff))

(define blodwen-bits-shl (lambda (x y bits) (remainder (arithmetic-shift x y) (arithmetic-shift 1 bits))))
(define blodwen-shl (lambda (x y) (arithmetic-shift x y)))
(define blodwen-shr (lambda (x y) (arithmetic-shift x (- y))))
(define blodwen-and (lambda (x y) (bitwise-and x y)))
(define blodwen-or (lambda (x y) (bitwise-ior x y)))
(define blodwen-xor (lambda (x y) (bitwise-xor x y)))

(define exact-floor
  (lambda (x)
    (inexact->exact (floor x))))

(define blodwen-bits-shl-signed
  (lambda (x y bits) (blodwen-toSignedInt (arithmetic-shift x y) bits)))

(define exact-truncate
  (lambda (x)
    (inexact->exact (truncate x))))

(define exact-truncate-boundedInt
  (lambda (x y)
    (blodwen-toSignedInt (exact-truncate x) y)))

(define exact-truncate-boundedUInt
  (lambda (x y)
    (blodwen-toUnsignedInt (exact-truncate x) y)))

(define cast-char-boundedInt
  (lambda (x y)
    (blodwen-toSignedInt (char->integer x) y)))

(define cast-char-boundedUInt
  (lambda (x y)
    (blodwen-toUnsignedInt (char->integer x) y)))

(define cast-string-int
  (lambda (x)
    (exact-truncate (cast-num (string->number (destroy-prefix x))))))

(define cast-string-boundedInt
  (lambda (x y)
    (blodwen-toSignedInt (cast-string-int x) y)))

(define cast-string-boundedUInt
  (lambda (x y)
    (blodwen-toUnsignedInt (cast-string-int x) y)))

(define cast-num
  (lambda (x)
    (if (number? x) x 0)))
(define destroy-prefix
  (lambda (x)
    (cond
      ((equal? x "") "")
      ((equal? (string-ref x 0) #\#) "")
      (else x))))

(define cast-int-char
  (lambda (x)
    (if (or
          (and (>= x 0) (<= x #xd7ff))
          (and (>= x #xe000) (<= x #x10ffff)))
        (integer->char x)
        (integer->char 0))))

(define cast-string-double
  (lambda (x)
    (exact->inexact (cast-num (string->number (destroy-prefix x))))))
(define (string-concat xs) (apply string-append xs))
(define (string-unpack s) (string->list s))
(define (string-pack xs) (list->string xs))
(define string-cons (lambda (x y) (string-append (string x) y)))
(define string-reverse (lambda (x)
  (list->string (reverse (string->list x)))))
(define (string-substr off len s)
    (let* ((l (string-length s))
          (b (max 0 off))
          (x (max 0 len))
          (end (min l (+ b x))))
          (substring s b end)))

(define (blodwen-string-iterator-new s)
  0)

(define (blodwen-string-iterator-to-string _ s ofs f)
  (f (substring s ofs (string-length s))))

(define (blodwen-string-iterator-next s ofs)
  (if (>= ofs (string-length s))
      '() ; EOF
      (cons (string-ref s ofs) (+ ofs 1))))

(define either-left
  (lambda (x)
    (vector 0 x)))

(define either-right
  (lambda (x)
    (vector 1 x)))

(define blodwen-error-quit
  (lambda (msg)
    (display msg)
    (newline)
    (exit 1)))

(define (blodwen-get-line p)
    (if (port? p)
        (let ((str (read-line p)))
            (if (eof-object? str)
                ""
                str))
        (void)))

(define (blodwen-get-char p)
    (if (port? p)
        (let ((chr (read-char p)))
            (if (eof-object? chr)
                #\nul
                chr))
        (void)))

;; Buffers

(define (blodwen-new-buffer size)
  (make-bytevector size 0))

(define (blodwen-buffer-size buf)
  (bytevector-length buf))

(define (blodwen-buffer-setbyte buf loc val)
  (bytevector-u8-set! buf loc val))

(define (blodwen-buffer-getbyte buf loc)
  (bytevector-u8-ref buf loc))

(define (blodwen-buffer-setbits16 buf loc val)
  (bytevector-u16-set! buf loc val (native-endianness)))

(define (blodwen-buffer-getbits16 buf loc)
  (bytevector-u16-ref buf loc (native-endianness)))

(define (blodwen-buffer-setbits32 buf loc val)
  (bytevector-u32-set! buf loc val (native-endianness)))

(define (blodwen-buffer-getbits32 buf loc)
  (bytevector-u32-ref buf loc (native-endianness)))

(define (blodwen-buffer-setbits64 buf loc val)
  (bytevector-u64-set! buf loc val (native-endianness)))

(define (blodwen-buffer-getbits64 buf loc)
  (bytevector-u64-ref buf loc (native-endianness)))

(define (blodwen-buffer-setint32 buf loc val)
  (bytevector-s32-set! buf loc val (native-endianness)))

(define (blodwen-buffer-getint32 buf loc)
  (bytevector-s32-ref buf loc (native-endianness)))

(define (blodwen-buffer-setint buf loc val)
  (bytevector-s64-set! buf loc val (native-endianness)))

(define (blodwen-buffer-getint buf loc)
  (bytevector-s64-ref buf loc (native-endianness)))

(define (blodwen-buffer-setdouble buf loc val)
  (bytevector-ieee-double-set! buf loc val (native-endianness)))

(define (blodwen-buffer-getdouble buf loc)
  (bytevector-ieee-double-ref buf loc (native-endianness)))

(define (blodwen-stringbytelen str)
  (bytevector-length (string->utf8 str)))

(define (blodwen-buffer-setstring buf loc val)
  (let* [(strvec (string->utf8 val))
         (len (bytevector-length strvec))]
    (bytevector-copy! strvec 0 buf loc len)))

(define (blodwen-buffer-getstring buf loc len)
  (let [(newvec (make-bytevector len))]
    (bytevector-copy! buf loc newvec 0 len)
    (utf8->string newvec)))

(define (blodwen-buffer-copydata buf start len dest loc)
  (bytevector-copy! buf start dest loc len))

;; Threads

;; NB: Racket threads are green/virtual threads meaning extra caution is to be
;; taken when using FFI functions in combination with threads. The *entire*
;; Racket runtime blocks on a foreign call, meaning no threads will progress
;; until the foreign call returns.

(define (blodwen-thread proc)
  (thread (lambda () (proc (vector 0)))))

(define (blodwen-thread-wait handle)
  (thread-wait handle))

;; Thread mailboxes

(define blodwen-thread-data (make-thread-cell #f))

(define (blodwen-get-thread-data ty)
  (thread-cell-ref blodwen-thread-data))

(define (blodwen-set-thread-data ty a)
  (thread-cell-set! blodwen-thread-data a))

;; Semaphores

(define (blodwen-make-semaphore init)
  (make-semaphore init))

(define (blodwen-semaphore-post sema)
  (semaphore-post sema))

(define (blodwen-semaphore-wait sema)
  (semaphore-wait sema))

;; Barriers

(struct barrier (count-box num-threads mutex semaphore))

(define (blodwen-make-barrier num-threads)
  (barrier (box 0) num-threads (blodwen-make-mutex) (make-semaphore 0)))

(define (blodwen-barrier-wait barrier)
  (blodwen-mutex-acquire (barrier-mutex barrier))
  (let* [(count-box (barrier-count-box barrier))
         (count-old (unbox count-box))
         (count-new (+ count-old 1))
         (sema (barrier-semaphore barrier))]
    (set-box! count-box count-new)
    (blodwen-mutex-release (barrier-mutex barrier))
    (when (= count-new (barrier-num-threads barrier)) (semaphore-post sema))
    (semaphore-wait sema)
    (semaphore-post sema)
    ))

;; Channels

(define (blodwen-make-channel ty)
  (make-async-channel 1))

(define (blodwen-channel-get ty chan)
  (async-channel-get chan))

(define (blodwen-channel-put ty chan val)
  (async-channel-put chan val))

;; Mutex

(define (blodwen-make-mutex)
  (make-semaphore 1))

(define (blodwen-mutex-acquire sema)
  (semaphore-wait sema))

(define (blodwen-mutex-release sema)
  (if (semaphore-try-wait? sema)
      (blodwen-error-quit "Exception in mutexRelease: thread does not own mutex")
      (semaphore-post sema)))

;; Condition Variables
;; As per p.5 of the MS paper
;; https://www.microsoft.com/en-us/research/wp-content/uploads/2004/12/ImplementingCVs.pdf

; The MS paper has the mutex be part of the CV, but that seems to be contrary to
; most other implementations
(struct cv (countingSem waitersLock waiters handshakeSem) #:mutable)

; CONSTRUCTOR
(define (blodwen-make-cv)
  (let ([s (make-semaphore 0)]
        [x (make-semaphore 1)]
        [h (make-semaphore 0)])
    (cv s x 0 h)))

;; MS paper: sem.V() := sem-post  /* "sem.V() increments sem.count, atomically" */
;;           sem.P() := sem-wait
;; (turns out this is Dijkstra's fault: P and V match up with the Dutch
;;  terminology)

; WAIT
(define (blodwen-cv-wait my-cv m)
    ; atomically increment waiters
    (semaphore-wait (cv-waitersLock my-cv))
    (set-cv-waiters! my-cv (+ (cv-waiters my-cv) 1))
    (semaphore-post (cv-waitersLock my-cv))
    ; release the provided mutex
    (blodwen-mutex-release m)
    ; wait for the counting semaphore to let us through
    (semaphore-wait (cv-countingSem my-cv))
    ; signal to broadcast that we have proceeded past the critical point/have
    ; been woken up successfully
    (semaphore-post (cv-handshakeSem my-cv))
    ; re-acquire the provided mutex
    (blodwen-mutex-acquire m)
    )

; SIGNAL
(define (blodwen-cv-signal my-cv)
    ; lock access to waiters
    (semaphore-wait (cv-waitersLock my-cv))
    (let ([waiters (cv-waiters my-cv)])
      (if (> waiters 0)

        ; if we have waiting threads, signal one of them
        (begin
          (set-cv-waiters! my-cv (- waiters 1))
          ; increment the counting semaphore to wake up a thread
          (semaphore-post (cv-countingSem my-cv))
          ; wait for the thread to tell us it's okay to proceed
          (semaphore-wait (cv-handshakeSem my-cv))
          )

        ; otherwise, do nothing
        (void)
        )
       ; unlock access to waiters
       (semaphore-post (cv-waitersLock my-cv))
       ))

; BROADCAST HELPERS

; for (int i = 0; i < waiters; i++) s.V();
(define (broadcast-for-helper my-cv i)
    (if (= i 0)
      ; if i is zero, we're done
      (void)
      ; otherwise, we signal one waiting thread, decrement i, and keep going
      (begin
        (semaphore-post (cv-countingSem my-cv))

        (broadcast-for-helper my-cv (- i 1))
        )))

; while (waiters > 0) { waiters--; h.P(); }
(define (broadcast-while-helper my-cv waiters)
    (if (= waiters 0)
      ; if waiters is 0, we're done
      (void)
      ; otherwise, wait for "waiters" many threads to tell us they're awake
      (begin
        (semaphore-wait (cv-handshakeSem my-cv))
        (broadcast-while-helper my-cv (- waiters 1))
        )))

; BROADCAST
(define (blodwen-cv-broadcast my-cv)
    ; lock access to waiters
    (semaphore-wait (cv-waitersLock my-cv))
    (let ([waiters (cv-waiters my-cv)])
      ; signal "waiters" many threads; counting *until* 0 in the helper
      ; function, hence "waiters" and NOT "waiters - 1"
      (broadcast-for-helper my-cv waiters)
      ; wait on "waiters" many threads to have been woken
      (broadcast-while-helper my-cv waiters)
      ; unlock access to waiters
      (semaphore-post (cv-waitersLock my-cv))
      ))

; FIXME: Maybe later. Possibly difficult because of the handshake thingy?
;(define (blodwen-cv-wait-timeout my-cv lockM timeout)
;  ;; precondition: calling thread holds lockM
;   (semaphore-wait (cv-waitersLock my-cv))                 ; x.P()
;   (set-cv-waiters! my-cv (+ (cv-waiters my-cv) 1)) ; waiters++
;   (semaphore-post (cv-waitersLock my-cv))                 ; x.V()
;   (blodwen-mutex-release lockM)                    ; m.Release()
;
;   (sync/timeout (/ timeout 1000000) (cv-countingSem my-cv))
;
;   (semaphore-wait (cv-countingSem my-cv))                 ; s.P()
;   (semaphore-post (cv-handshakeSem my-cv))                 ; h.V()
;   (blodwen-mutex-acquire lockM)                    ; m.Acquire()
;   )


(define (blodwen-make-future work) (future work))
(define (blodwen-await-future ty future) (touch future))

;; NB: These should *ALWAYS* be used in multi-threaded programs since Racket
;; threads are green/virtual threads and so using an external function will
;; block the *entire* runtime until the function returns. This is fine for most
;; things, but not for `sleep`.
(define (blodwen-sleep s) (sleep s))
(define (blodwen-usleep us) (sleep (* 0.000001 us)))

(define (blodwen-clock-time-utc) (current-time 'time-utc))
(define (blodwen-clock-time-monotonic) (current-time 'time-monotonic))
(define (blodwen-clock-time-duration) (current-time 'time-duration))
(define (blodwen-clock-time-process) (current-time 'time-process))
(define (blodwen-clock-time-thread) (current-time 'time-thread))
(define (blodwen-clock-time-gccpu) 0) ;; unsupported
(define (blodwen-clock-time-gcreal) 0) ;; unsupported
(define (blodwen-is-time? clk) (if (time? clk) 1 0))
(define (blodwen-clock-second time) (time-second time))
(define (blodwen-clock-nanosecond time) (time-nanosecond time))

(define (blodwen-arg-count)
  (+ (vector-length (current-command-line-arguments)) 1))

(define (blodwen-arg n)
  (cond
    ((= n 0) (path->string (find-system-path 'run-file)))
    ((< n (+ (vector-length (current-command-line-arguments)) 1))
        (vector-ref (current-command-line-arguments) (- n 1)))
     (else "")))

;; Randoms
(random-seed (date*-nanosecond (current-date))) ; initialize random seed

(define (blodwen-random-seed s) (random-seed s))
(define blodwen-random
  (case-lambda
    ;; no argument, pick a real value from [0, 1.0)
    [() (random)]
    ;; single argument k, pick an integral value from [0, k)
    [(k) (if (> k 0)
           (random k)
           (raise 'blodwen-random-invalid-range-argument))]))

;; For finalisers

(define (blodwen-register-object obj proc)
   (register-finalizer obj (lambda (ptr) ((proc ptr) 'erased)))
   obj)

;; For creating and reading back scheme objects

(define ns (make-base-namespace))

; read a scheme string and evaluate it, returning 'Just result' on success
; TODO: catch exception!
(define (blodwen-eval-scheme str)
  (with-handlers ([exn:fail? (lambda (x) '())]) ; Nothing on failure
     (box (eval (read (open-input-string str)) ns))) ; box == Just
)

(define (blodwen-eval-okay obj)
  (if (null? obj)
      0
      1))

(define (blodwen-get-eval-result obj)
  (unbox obj))

(define (blodwen-debug-scheme obj)
  (display obj) (newline))

(define (blodwen-is-number obj)
  (if (number? obj) 1 0))

(define (blodwen-is-integer obj)
  (if (and (number? obj) (exact? obj)) 1 0))

(define (blodwen-is-float obj)
  (if (flonum? obj) 1 0))

(define (blodwen-is-char obj)
  (if (char? obj) 1 0))

(define (blodwen-is-string obj)
  (if (string? obj) 1 0))

(define (blodwen-is-procedure obj)
  (if (procedure? obj) 1 0))

(define (blodwen-is-symbol obj)
  (if (symbol? obj) 1 0))

(define (blodwen-is-vector obj)
  (if (vector? obj) 1 0))

(define (blodwen-is-nil obj)
  (if (null? obj) 1 0))

(define (blodwen-is-pair obj)
  (if (pair? obj) 1 0))

(define (blodwen-is-box obj)
  (if (box? obj) 1 0))

(define (blodwen-make-symbol str)
  (string->symbol str))

; The below rely on checking that the objects are the right type first.

(define (blodwen-vector-ref obj i)
  (vector-ref obj i))

(define (blodwen-vector-length obj)
  (vector-length obj))

(define (blodwen-vector-list obj)
  (vector->list obj))

(define (blodwen-unbox obj)
  (unbox obj))

(define (blodwen-apply obj arg)
  (obj arg))

(define (blodwen-force obj)
  (obj))

(define (blodwen-read-symbol sym)
  (symbol->string sym))

(define (blodwen-id x) x)
(define PreludeC-45Types-fastUnpack (lambda (farg-0) (string-unpack farg-0)))
(define PreludeC-45Types-fastPack (lambda (farg-0) (string-pack farg-0)))
(define PreludeC-45Types-fastConcat (lambda (farg-0) (string-concat farg-0)))
(define PreludeC-45IO-prim__putStr (lambda (farg-0 farg-1) (idris2_putStr farg-0) (vector 0 )))
(define csegen-7 (cons (lambda (arg-8336) (lambda (arg-8339) (string-append arg-8336 arg-8339))) ""))
(define LanguageC-45ReflectionC-45Derive-mkShowPrec (lambda (arg-1) (cons (arg-1 (vector 0 )) arg-1)))
(define PreludeC-45Show-showParens (lambda (arg-0 arg-1) (cond ((equal? arg-0 0) arg-1) (else (string-append "(" (string-append arg-1 ")"))))))
(define PreludeC-45EqOrd-u--C-61C-61_Eq_Ordering (lambda (arg-0 arg-1) (cond ((equal? arg-0 0) (cond ((equal? arg-1 0) 1)(else 0))) ((equal? arg-0 1) (cond ((equal? arg-1 1) 1)(else 0))) ((equal? arg-0 2) (cond ((equal? arg-1 2) 1)(else 0)))(else 0))))
(define PreludeC-45EqOrd-u--C-47C-61_Eq_Ordering (lambda (arg-0 arg-1) (let ((sc0 (PreludeC-45EqOrd-u--C-61C-61_Eq_Ordering arg-0 arg-1))) (cond ((equal? sc0 1) 0) (else 1)))))
(define PreludeC-45Show-precCon (lambda (arg-0) (case (vector-ref arg-0 0) ((0) 0) ((1) 1) ((2) 2) ((3) 3) ((4) 4) ((5) 5) (else 6))))
(define PreludeC-45EqOrd-u--C-60_Ord_Integer (lambda (arg-0 arg-1) (let ((sc0 (or (and (< arg-0 arg-1) 1) 0))) (cond ((equal? sc0 0) 0)(else 1)))))
(define PreludeC-45EqOrd-u--C-61C-61_Eq_Integer (lambda (arg-0 arg-1) (let ((sc0 (or (and (= arg-0 arg-1) 1) 0))) (cond ((equal? sc0 0) 0)(else 1)))))
(define PreludeC-45EqOrd-u--compare_Ord_Integer (lambda (arg-0 arg-1) (let ((sc0 (PreludeC-45EqOrd-u--C-60_Ord_Integer arg-0 arg-1))) (cond ((equal? sc0 1) 0) (else (let ((sc1 (PreludeC-45EqOrd-u--C-61C-61_Eq_Integer arg-0 arg-1))) (cond ((equal? sc1 1) 1) (else 2))))))))
(define PreludeC-45Show-u--compare_Ord_Prec (lambda (arg-0 arg-1) (case (vector-ref arg-0 0) ((4) (let ((e-0 (vector-ref arg-0 1))) (case (vector-ref arg-1 0) ((4) (let ((e-1 (vector-ref arg-1 1))) (PreludeC-45EqOrd-u--compare_Ord_Integer e-0 e-1)))(else (PreludeC-45EqOrd-u--compare_Ord_Integer (PreludeC-45Show-precCon arg-0) (PreludeC-45Show-precCon arg-1))))))(else (PreludeC-45EqOrd-u--compare_Ord_Integer (PreludeC-45Show-precCon arg-0) (PreludeC-45Show-precCon arg-1))))))
(define PreludeC-45Show-u--C-62C-61_Ord_Prec (lambda (arg-0 arg-1) (PreludeC-45EqOrd-u--C-47C-61_Eq_Ordering (PreludeC-45Show-u--compare_Ord_Prec arg-0 arg-1) 0)))
(define PreludeC-45Show-showCon (lambda (arg-0 arg-1 arg-2) (PreludeC-45Show-showParens (PreludeC-45Show-u--C-62C-61_Ord_Prec arg-0 (vector 6 )) (string-append arg-1 arg-2))))
(define PreludeC-45Types-u--foldl_Foldable_List (lambda (arg-2 arg-3 arg-4) (if (null? arg-4) arg-3 (let ((e-2 (car arg-4))) (let ((e-3 (cdr arg-4))) (PreludeC-45Types-u--foldl_Foldable_List arg-2 ((arg-2 arg-3) e-2) e-3))))))
(define PreludeC-45Types-u--foldMap_Foldable_List (lambda (arg-2 arg-3 ext-0) (PreludeC-45Types-u--foldl_Foldable_List (lambda (u--acc) (lambda (u--elem) (let ((e-1 (car arg-2))) ((e-1 u--acc) (arg-3 u--elem))))) (let ((e-2 (cdr arg-2))) e-2) ext-0)))
(define DeriveC-45Show-conWithArgs (lambda (arg-0 arg-1 arg-2) (if (null? arg-2) arg-1 (PreludeC-45Show-showCon arg-0 arg-1 (PreludeC-45Types-u--foldMap_Foldable_List csegen-7 (lambda (eta-0) eta-0) arg-2)))))
(define PreludeC-45Show-showArg (lambda (arg-1 arg-2) (string-append " " (let ((e-2 (cdr arg-1))) ((e-2 (vector 6 )) arg-2)))))
(define PreludeC-45Show-firstCharIs (lambda (arg-0 arg-1) (cond ((equal? arg-1 "") 0)(else (arg-0 (string-ref arg-1 0))))))
(define PreludeC-45EqOrd-u--C-61C-61_Eq_Char (lambda (arg-0 arg-1) (let ((sc0 (or (and (char=? arg-0 arg-1) 1) 0))) (cond ((equal? sc0 0) 0)(else 1)))))
(define PreludeC-45Show-primNumShow (lambda (arg-1 arg-2 arg-3) (let ((u--str (arg-1 arg-3))) (PreludeC-45Show-showParens (let ((sc0 (PreludeC-45Show-u--C-62C-61_Ord_Prec arg-2 (vector 5 )))) (cond ((equal? sc0 1) (PreludeC-45Show-firstCharIs (lambda (arg-0) (PreludeC-45EqOrd-u--C-61C-61_Eq_Char arg-0 #\-)) u--str)) (else 0))) u--str))))
(define PreludeC-45Show-u--showPrec_Show_Double (lambda (ext-0 ext-1) (PreludeC-45Show-primNumShow (lambda (eta-0) (number->string eta-0)) ext-0 ext-1)))
(define PreludeC-45Types-getAt (lambda (arg-1 arg-2) (cond ((equal? arg-1 0) (if (null? arg-2) '() (let ((e-3 (car arg-2))) (box e-3))))(else (let ((e-1 (- arg-1 1))) (if (null? arg-2) '() (let ((e-7 (cdr arg-2))) (PreludeC-45Types-getAt e-1 e-7))))))))
(define PreludeC-45EqOrd-u--C-60C-61_Ord_Char (lambda (arg-0 arg-1) (let ((sc0 (or (and (char<=? arg-0 arg-1) 1) 0))) (cond ((equal? sc0 0) 0)(else 1)))))
(define PreludeC-45EqOrd-u--C-62C-61_Ord_Char (lambda (arg-0 arg-1) (let ((sc0 (or (and (char>=? arg-0 arg-1) 1) 0))) (cond ((equal? sc0 0) 0)(else 1)))))
(define PreludeC-45Types-isDigit (lambda (arg-0) (let ((sc0 (PreludeC-45EqOrd-u--C-62C-61_Ord_Char arg-0 #\0))) (cond ((equal? sc0 1) (PreludeC-45EqOrd-u--C-60C-61_Ord_Char arg-0 #\9)) (else 0)))))
(define PreludeC-45Types-prim__integerToNat (lambda (arg-0) (let ((sc0 (or (and (<= 0 arg-0) 1) 0))) (cond ((equal? sc0 0) 0)(else arg-0)))))
(define PreludeC-45Show-protectEsc (lambda (arg-0 arg-1 arg-2) (string-append arg-1 (string-append (let ((sc0 (PreludeC-45Show-firstCharIs arg-0 arg-2))) (cond ((equal? sc0 1) "\\&") (else ""))) arg-2))))
(define PreludeC-45EqOrd-u--C-62_Ord_Char (lambda (arg-0 arg-1) (let ((sc0 (or (and (char>? arg-0 arg-1) 1) 0))) (cond ((equal? sc0 0) 0)(else 1)))))
(define PreludeC-45Show-u--showPrec_Show_Int (lambda (ext-0 ext-1) (PreludeC-45Show-primNumShow (lambda (eta-0) (number->string eta-0)) ext-0 ext-1)))
(define PreludeC-45Show-u--show_Show_Int (lambda (arg-0) (PreludeC-45Show-u--showPrec_Show_Int (vector 0 ) arg-0)))
(define PreludeC-45Show-n--2437-11793-u--asciiTab (lambda (arg-0) (cons "NUL" (cons "SOH" (cons "STX" (cons "ETX" (cons "EOT" (cons "ENQ" (cons "ACK" (cons "BEL" (cons "BS" (cons "HT" (cons "LF" (cons "VT" (cons "FF" (cons "CR" (cons "SO" (cons "SI" (cons "DLE" (cons "DC1" (cons "DC2" (cons "DC3" (cons "DC4" (cons "NAK" (cons "SYN" (cons "ETB" (cons "CAN" (cons "EM" (cons "SUB" (cons "ESC" (cons "FS" (cons "GS" (cons "RS" (cons "US" '()))))))))))))))))))))))))))))))))))
(define PreludeC-45Show-showLitChar (lambda (arg-0) (cond ((equal? arg-0 (integer->char 7)) (lambda (arg-1) (string-append "\\a" arg-1))) ((equal? arg-0 (integer->char 8)) (lambda (arg-1) (string-append "\\b" arg-1))) ((equal? arg-0 (integer->char 12)) (lambda (arg-1) (string-append "\\f" arg-1))) ((equal? arg-0 (integer->char 10)) (lambda (arg-1) (string-append "\\n" arg-1))) ((equal? arg-0 (integer->char 13)) (lambda (arg-1) (string-append "\\r" arg-1))) ((equal? arg-0 (integer->char 9)) (lambda (arg-1) (string-append "\\t" arg-1))) ((equal? arg-0 (integer->char 11)) (lambda (arg-1) (string-append "\\v" arg-1))) ((equal? arg-0 (integer->char 14)) (lambda (eta-0) (PreludeC-45Show-protectEsc (lambda (arg-1) (PreludeC-45EqOrd-u--C-61C-61_Eq_Char arg-1 #\H)) "\\SO" eta-0))) ((equal? arg-0 (integer->char 127)) (lambda (arg-1) (string-append "\\DEL" arg-1))) ((equal? arg-0 #\\) (lambda (arg-1) (string-append "\\\\" arg-1)))(else (lambda (clam-0) (let ((sc0 (PreludeC-45Types-getAt (PreludeC-45Types-prim__integerToNat (char->integer arg-0)) (PreludeC-45Show-n--2437-11793-u--asciiTab arg-0)))) (if (null? sc0) (let ((sc1 (PreludeC-45EqOrd-u--C-62_Ord_Char arg-0 (integer->char 127)))) (cond ((equal? sc1 1) (string-cons #\\ (PreludeC-45Show-protectEsc (lambda (eta-0) (PreludeC-45Types-isDigit eta-0)) (PreludeC-45Show-u--show_Show_Int (cast-char-boundedInt arg-0 63)) clam-0))) (else (string-cons arg-0 clam-0)))) (let ((e-1 (unbox sc0))) (string-cons #\\ (string-append e-1 clam-0))))))))))
(define PreludeC-45Show-showLitString (lambda (arg-0) (lambda (clam-0) (if (null? arg-0) clam-0 (let ((e-2 (car arg-0))) (let ((e-3 (cdr arg-0))) (cond ((equal? e-2 #\") (string-append "\\\"" ((PreludeC-45Show-showLitString e-3) clam-0)))(else ((PreludeC-45Show-showLitChar e-2) ((PreludeC-45Show-showLitString e-3) clam-0))))))))))
(define PreludeC-45Show-u--show_Show_String (lambda (arg-0) (string-cons #\" ((PreludeC-45Show-showLitString (PreludeC-45Types-fastUnpack arg-0)) "\""))))
(define PreludeC-45Show-u--showPrec_Show_String (lambda (arg-0 arg-1) (PreludeC-45Show-u--show_Show_String arg-1)))
(define PreludeC-45Show-u--show_Show_Double (lambda (arg-0) (PreludeC-45Show-u--showPrec_Show_Double (vector 0 ) arg-0)))
(define MathExpr-showPrecJsonTree (lambda (arg-0 arg-1) (case (vector-ref arg-1 0) ((0) (let ((e-0 (vector-ref arg-1 1))) (DeriveC-45Show-conWithArgs arg-0 "Lit3" (cons (PreludeC-45Show-showArg (cons (lambda (u--x) (PreludeC-45Show-u--show_Show_Double u--x)) (lambda (u--d) (lambda (u--x) (PreludeC-45Show-u--showPrec_Show_Double u--d u--x)))) e-0) '())))) ((1) (let ((e-1 (vector-ref arg-1 1))) (let ((e-2 (vector-ref arg-1 2))) (DeriveC-45Show-conWithArgs arg-0 "Add2" (cons (PreludeC-45Show-showArg (csegen-9) e-1) (cons (PreludeC-45Show-showArg (csegen-9) e-2) '())))))) ((2) (let ((e-3 (vector-ref arg-1 1))) (let ((e-4 (vector-ref arg-1 2))) (DeriveC-45Show-conWithArgs arg-0 "Sub2" (cons (PreludeC-45Show-showArg (csegen-9) e-3) (cons (PreludeC-45Show-showArg (csegen-9) e-4) '())))))) ((3) (let ((e-5 (vector-ref arg-1 1))) (let ((e-6 (vector-ref arg-1 2))) (DeriveC-45Show-conWithArgs arg-0 "Mul2" (cons (PreludeC-45Show-showArg (csegen-9) e-5) (cons (PreludeC-45Show-showArg (csegen-9) e-6) '())))))) ((4) (let ((e-7 (vector-ref arg-1 1))) (let ((e-8 (vector-ref arg-1 2))) (DeriveC-45Show-conWithArgs arg-0 "Div2" (cons (PreludeC-45Show-showArg (csegen-9) e-7) (cons (PreludeC-45Show-showArg (csegen-9) e-8) '())))))) (else (let ((e-9 (vector-ref arg-1 1))) (DeriveC-45Show-conWithArgs arg-0 "Var2" (cons (PreludeC-45Show-showArg (cons (lambda (u--x) (PreludeC-45Show-u--show_Show_String u--x)) (lambda (u--d) (lambda (u--x) (PreludeC-45Show-u--showPrec_Show_String u--d u--x)))) e-9) '())))))))
(define csegen-9 (lambda () (LanguageC-45ReflectionC-45Derive-mkShowPrec (lambda (eta-0) (lambda (eta-1) (MathExpr-showPrecJsonTree eta-0 eta-1))))))
(define PreludeC-45EqOrd-u--C-61C-61_Eq_Double (lambda (arg-0 arg-1) (let ((sc0 (or (and (= arg-0 arg-1) 1) 0))) (cond ((equal? sc0 0) 0)(else 1)))))
(define PreludeC-45EqOrd-u--C-61C-61_Eq_String (lambda (arg-0 arg-1) (let ((sc0 (or (and (string=? arg-0 arg-1) 1) 0))) (cond ((equal? sc0 0) 0)(else 1)))))
(define MathExpr-eqJsonTree (lambda (arg-0 arg-1) (case (vector-ref arg-0 0) ((0) (let ((e-0 (vector-ref arg-0 1))) (case (vector-ref arg-1 0) ((0) (let ((e-10 (vector-ref arg-1 1))) (PreludeC-45EqOrd-u--C-61C-61_Eq_Double e-0 e-10)))(else 0)))) ((1) (let ((e-1 (vector-ref arg-0 1))) (let ((e-2 (vector-ref arg-0 2))) (case (vector-ref arg-1 0) ((1) (let ((e-11 (vector-ref arg-1 1))) (let ((e-12 (vector-ref arg-1 2))) (let ((sc2 (MathExpr-eqJsonTree e-1 e-11))) (cond ((equal? sc2 1) (MathExpr-eqJsonTree e-2 e-12)) (else 0))))))(else 0))))) ((2) (let ((e-3 (vector-ref arg-0 1))) (let ((e-4 (vector-ref arg-0 2))) (case (vector-ref arg-1 0) ((2) (let ((e-13 (vector-ref arg-1 1))) (let ((e-14 (vector-ref arg-1 2))) (let ((sc2 (MathExpr-eqJsonTree e-3 e-13))) (cond ((equal? sc2 1) (MathExpr-eqJsonTree e-4 e-14)) (else 0))))))(else 0))))) ((3) (let ((e-5 (vector-ref arg-0 1))) (let ((e-6 (vector-ref arg-0 2))) (case (vector-ref arg-1 0) ((3) (let ((e-15 (vector-ref arg-1 1))) (let ((e-16 (vector-ref arg-1 2))) (let ((sc2 (MathExpr-eqJsonTree e-5 e-15))) (cond ((equal? sc2 1) (MathExpr-eqJsonTree e-6 e-16)) (else 0))))))(else 0))))) ((4) (let ((e-7 (vector-ref arg-0 1))) (let ((e-8 (vector-ref arg-0 2))) (case (vector-ref arg-1 0) ((4) (let ((e-17 (vector-ref arg-1 1))) (let ((e-18 (vector-ref arg-1 2))) (let ((sc2 (MathExpr-eqJsonTree e-7 e-17))) (cond ((equal? sc2 1) (MathExpr-eqJsonTree e-8 e-18)) (else 0))))))(else 0))))) ((5) (let ((e-9 (vector-ref arg-0 1))) (case (vector-ref arg-1 0) ((5) (let ((e-19 (vector-ref arg-1 1))) (PreludeC-45EqOrd-u--C-61C-61_Eq_String e-9 e-19)))(else 0))))(else 0))))
(define MathExpr-eqJSToken (lambda (arg-0 arg-1) (case (vector-ref arg-0 0) ((0) (let ((e-0 (vector-ref arg-0 1))) (case (vector-ref arg-1 0) ((0) (let ((e-2 (vector-ref arg-1 1))) (PreludeC-45EqOrd-u--C-61C-61_Eq_Char e-0 e-2)))(else 0)))) ((1) (let ((e-1 (vector-ref arg-0 1))) (case (vector-ref arg-1 0) ((1) (let ((e-3 (vector-ref arg-1 1))) (MathExpr-eqJsonTree e-1 e-3)))(else 0)))) ((2) (case (vector-ref arg-1 0) ((2) 1)(else 0)))(else 0))))
(define csegen-37 (cons (lambda (eta-0) (lambda (eta-1) (MathExpr-eqJSToken eta-0 eta-1))) (lambda (u--a) (lambda (u--b) (let ((sc0 (MathExpr-eqJSToken u--a u--b))) (cond ((equal? sc0 1) 0) (else 1)))))))
(define PreludeC-45Show-u--show_Show_Char (lambda (arg-0) (cond ((equal? arg-0 #\') "'\\''")(else (string-cons #\' ((PreludeC-45Show-showLitChar arg-0) "'"))))))
(define PreludeC-45Show-u--showPrec_Show_Char (lambda (arg-0 arg-1) (PreludeC-45Show-u--show_Show_Char arg-1)))
(define MathExpr-showPrecJSToken (lambda (arg-0 arg-1) (case (vector-ref arg-1 0) ((0) (let ((e-0 (vector-ref arg-1 1))) (DeriveC-45Show-conWithArgs arg-0 "Symbol" (cons (PreludeC-45Show-showArg (cons (lambda (u--x) (PreludeC-45Show-u--show_Show_Char u--x)) (lambda (u--d) (lambda (u--x) (PreludeC-45Show-u--showPrec_Show_Char u--d u--x)))) e-0) '())))) ((1) (let ((e-1 (vector-ref arg-1 1))) (DeriveC-45Show-conWithArgs arg-0 "Lit" (cons (PreludeC-45Show-showArg (csegen-9) e-1) '())))) (else "Space"))))
(define csegen-48 (LanguageC-45ReflectionC-45Derive-mkShowPrec (lambda (eta-0) (lambda (eta-1) (MathExpr-showPrecJSToken eta-0 eta-1)))))
(define TextC-45Bounds-eqPosition (lambda (arg-0 arg-1) (let ((e-0 (car arg-0))) (let ((e-1 (cdr arg-0))) (let ((e-2 (car arg-1))) (let ((e-3 (cdr arg-1))) (let ((sc2 (or (and (= e-0 e-2) 1) 0))) (cond ((equal? sc2 1) (or (and (= e-1 e-3) 1) 0)) (else 0)))))))))
(define LanguageC-45ReflectionC-45Derive-mkOrd (lambda (arg-1 arg-2) (vector arg-1 arg-2 (lambda (u--a) (lambda (u--b) (PreludeC-45EqOrd-u--C-61C-61_Eq_Ordering ((arg-2 u--a) u--b) 0))) (lambda (u--a) (lambda (u--b) (PreludeC-45EqOrd-u--C-61C-61_Eq_Ordering ((arg-2 u--a) u--b) 2))) (lambda (u--a) (lambda (u--b) (PreludeC-45EqOrd-u--C-47C-61_Eq_Ordering ((arg-2 u--a) u--b) 2))) (lambda (u--a) (lambda (u--b) (PreludeC-45EqOrd-u--C-47C-61_Eq_Ordering ((arg-2 u--a) u--b) 0))) (lambda (u--a) (lambda (u--b) (let ((sc0 (PreludeC-45EqOrd-u--C-61C-61_Eq_Ordering ((arg-2 u--a) u--b) 2))) (cond ((equal? sc0 1) u--a) (else u--b))))) (lambda (u--a) (lambda (u--b) (let ((sc0 (PreludeC-45EqOrd-u--C-61C-61_Eq_Ordering ((arg-2 u--a) u--b) 0))) (cond ((equal? sc0 1) u--a) (else u--b))))))))
(define TextC-45Bounds-case--ordPosition-5490 (lambda (arg-0 arg-1 arg-2 arg-3 arg-4) (cond ((equal? arg-4 1) (PreludeC-45EqOrd-u--compare_Ord_Integer arg-0 arg-2))(else arg-4))))
(define TextC-45Bounds-ordPosition (lambda (arg-0 arg-1) (let ((e-0 (car arg-0))) (let ((e-1 (cdr arg-0))) (let ((e-2 (car arg-1))) (let ((e-3 (cdr arg-1))) (TextC-45Bounds-case--ordPosition-5490 e-1 e-0 e-3 e-2 (PreludeC-45EqOrd-u--compare_Ord_Integer e-0 e-2))))))))
(define csegen-104 (LanguageC-45ReflectionC-45Derive-mkOrd (cons (lambda (eta-0) (lambda (eta-1) (TextC-45Bounds-eqPosition eta-0 eta-1))) (lambda (u--a) (lambda (u--b) (let ((sc0 (TextC-45Bounds-eqPosition u--a u--b))) (cond ((equal? sc0 1) 0) (else 1)))))) (lambda (eta-0) (lambda (eta-1) (TextC-45Bounds-ordPosition eta-0 eta-1)))))
(define u--prim__sub_Integer (lambda (arg-0 arg-1) (- arg-0 arg-1)))
(define MathML-prettyPrintMathML (lambda (arg-0) (case (vector-ref arg-0 0) ((0) (let ((e-0 (vector-ref arg-0 1))) (string-append "<mrow>" (string-append (PreludeC-45Types-u--foldMap_Foldable_List csegen-7 (lambda (eta-0) (MathML-prettyPrintMathML eta-0)) e-0) "</mrow>")))) ((1) (let ((e-1 (vector-ref arg-0 1))) (let ((e-2 (vector-ref arg-0 2))) (string-append "<mfrac>" (string-append (MathML-prettyPrintMathML e-1) (string-append (MathML-prettyPrintMathML e-2) "</mfrac>")))))) ((2) (let ((e-3 (vector-ref arg-0 1))) (string-append "<msqrt>" (string-append (MathML-prettyPrintMathML e-3) "</msqrt>")))) ((3) (let ((e-4 (vector-ref arg-0 1))) (let ((e-5 (vector-ref arg-0 2))) (let ((e-6 (vector-ref arg-0 3))) (string-append "<mroot>" (string-append (MathML-prettyPrintMathML e-4) (string-append (MathML-prettyPrintMathML e-5) (string-append (MathML-prettyPrintMathML e-6) "</mroot>")))))))) ((4) (let ((e-7 (vector-ref arg-0 1))) (let ((e-8 (vector-ref arg-0 2))) (string-append "<msub>" (string-append (MathML-prettyPrintMathML e-7) (string-append (MathML-prettyPrintMathML e-8) "</msub>")))))) ((5) (let ((e-9 (vector-ref arg-0 1))) (let ((e-10 (vector-ref arg-0 2))) (string-append "<msup>" (string-append (MathML-prettyPrintMathML e-9) (string-append (MathML-prettyPrintMathML e-10) "</msup>")))))) ((6) (let ((e-11 (vector-ref arg-0 1))) (let ((e-12 (vector-ref arg-0 2))) (let ((e-13 (vector-ref arg-0 3))) (string-append "<msubsup>" (string-append (MathML-prettyPrintMathML e-11) (string-append (MathML-prettyPrintMathML e-12) (string-append (MathML-prettyPrintMathML e-13) "</msubsup>")))))))) ((7) (let ((e-14 (vector-ref arg-0 1))) (let ((e-15 (vector-ref arg-0 2))) (string-append "<munder>" (string-append (MathML-prettyPrintMathML e-14) (string-append (MathML-prettyPrintMathML e-15) "</munder>")))))) ((8) (let ((e-16 (vector-ref arg-0 1))) (let ((e-17 (vector-ref arg-0 2))) (string-append "<mover>" (string-append (MathML-prettyPrintMathML e-16) (string-append (MathML-prettyPrintMathML e-17) "</mover>")))))) ((9) (let ((e-18 (vector-ref arg-0 1))) (let ((e-19 (vector-ref arg-0 2))) (let ((e-20 (vector-ref arg-0 3))) (string-append "<munderover>" (string-append (MathML-prettyPrintMathML e-18) (string-append (MathML-prettyPrintMathML e-19) (string-append (MathML-prettyPrintMathML e-20) "</munderover>")))))))) ((10) (let ((e-21 (vector-ref arg-0 1))) (string-append "<mo>" (string-append e-21 "</mo>")))) ((11) (let ((e-22 (vector-ref arg-0 1))) (string-append "<mi>" (string-append e-22 "</mi>")))) (else (let ((e-23 (vector-ref arg-0 1))) (string-append "<mn>" (string-append e-23 "</mn>")))))))
(define Main-checkPrettyPrint (lambda (arg-0 arg-1) (let ((u--actual (MathML-prettyPrintMathML arg-0))) (lambda (clam-0) (let ((sc0 (PreludeC-45EqOrd-u--C-61C-61_Eq_String u--actual arg-1))) (cond ((equal? sc0 1) (PreludeC-45IO-prim__putStr "Pass\u000a" clam-0)) (else (PreludeC-45IO-prim__putStr (string-append (string-append "Fail: Expected: " (string-append arg-1 (string-append ", Actual: " u--actual))) "\u000a") clam-0))))))))
(define MathMLExamples-fracExample (vector 1 (vector 12 "1") (vector 12 "2")))
(define MathMLExamples-fracSupExample (vector 1 (vector 5 (vector 11 "a") (vector 12 "2")) (vector 5 (vector 11 "b") (vector 12 "3"))))
(define PreludeC-45Types-either (lambda (arg-3 arg-4 arg-5) (case (vector-ref arg-5 0) ((0) (let ((e-2 (vector-ref arg-5 1))) ((arg-3) e-2))) (else (let ((e-5 (vector-ref arg-5 1))) ((arg-4) e-5))))))
(define DataC-45List1-forget (lambda (arg-1) (let ((e-1 (car arg-1))) (let ((e-2 (cdr arg-1))) (cons e-1 e-2)))))
(define (MathExpr-tokJSON2 . any-args) (blodwen-error-quit "Encountered undefined name MathExpr.tokJSON2"))
(define PreludeC-45TypesC-45List-reverseOnto (lambda (arg-1 arg-2) (if (null? arg-2) arg-1 (let ((e-2 (car arg-2))) (let ((e-3 (cdr arg-2))) (PreludeC-45TypesC-45List-reverseOnto (cons e-2 arg-1) e-3))))))
(define PreludeC-45TypesC-45List-reverse (lambda (ext-0) (PreludeC-45TypesC-45List-reverseOnto '() ext-0)))
(define PreludeC-45TypesC-45List-tailRecAppend (lambda (arg-1 arg-2) (PreludeC-45TypesC-45List-reverseOnto arg-2 (PreludeC-45TypesC-45List-reverse arg-1))))
(define DataC-45List1-appendl (lambda (arg-1 arg-2) (let ((e-1 (car arg-1))) (let ((e-2 (cdr arg-1))) (cons e-1 (PreludeC-45TypesC-45List-tailRecAppend e-2 arg-2))))))
(define DataC-45List1-C-43C-43 (lambda (arg-1 arg-2) (DataC-45List1-appendl arg-1 (DataC-45List1-forget arg-2))))
(define PreludeC-45Interfaces-C-42C-62 (lambda (arg-3 arg-4 arg-5) (let ((e-3 (vector-ref arg-3 2))) ((((e-3 'erased) 'erased) (((let ((eff-0 (let ((e-6 (vector-ref arg-3 0))) e-6))) (lambda (arg-0) (lambda (arg-1) ((((eff-0 'erased) 'erased) arg-0) arg-1)))) (lambda (eta-0) (lambda (eta-1) eta-1))) arg-4)) arg-5))))
(define TextC-45Bounds-u--C-60C-43C-62_Semigroup_Bounds (lambda (arg-0 arg-1) (if (null? arg-0) arg-1 (if (null? arg-1) arg-0 (let ((e-0 (car arg-0))) (let ((e-1 (cdr arg-0))) (let ((e-2 (car arg-1))) (let ((e-3 (cdr arg-1))) (cons (let ((sc4 csegen-104)) (let ((e-8 (vector-ref sc4 7))) ((e-8 e-0) e-2))) (let ((sc4 csegen-104)) (let ((e-7 (vector-ref sc4 6))) ((e-7 e-1) e-3))))))))))))
(define TextC-45Bounds-app (lambda (arg-2 arg-3) (let ((e-1 (car arg-2))) (let ((e-2 (cdr arg-2))) (let ((e-4 (car arg-3))) (let ((e-5 (cdr arg-3))) (cons (e-1 e-4) (TextC-45Bounds-u--C-60C-43C-62_Semigroup_Bounds e-2 e-5))))))))
(define TextC-45Bounds-u--map_Functor_Bounded (lambda (arg-2 arg-3) (let ((e-1 (car arg-3))) (let ((e-2 (cdr arg-3))) (cons (arg-2 e-1) e-2)))))
(define TextC-45ParseC-45Core-merge (lambda (arg-7 arg-8) (case (vector-ref arg-8 0) ((1) (let ((e-6 (vector-ref arg-8 1))) (let ((e-7 (vector-ref arg-8 2))) (let ((e-8 (vector-ref arg-8 3))) (let ((e-9 (vector-ref arg-8 4))) (vector 1 e-6 (PreludeC-45Interfaces-C-42C-62 (vector (lambda (u--b) (lambda (u--a) (lambda (u--func) (lambda (arg-8747) (TextC-45Bounds-u--map_Functor_Bounded u--func arg-8747))))) (lambda (u--a) (lambda (arg-9793) (cons arg-9793 '()))) (lambda (u--b) (lambda (u--a) (lambda (arg-9799) (lambda (arg-9806) (TextC-45Bounds-app arg-9799 arg-9806)))))) arg-7 e-7) e-8 e-9))))))(else arg-8))))
(define DataC-45ListC-45Suffix-weakens (lambda (arg-4) (cond ((equal? arg-4 0) (blodwen-error-quit "Nat case not covered"))(else (let ((e-6 (- arg-4 1))) (+ e-6 1))))))
(define TextC-45ParseC-45Core-succ (lambda (arg-8 arg-9) (case (vector-ref arg-8 0) ((0) (let ((e-6 (vector-ref arg-8 1))) (let ((e-7 (vector-ref arg-8 2))) (vector 0 e-6 e-7)))) (else (let ((e-14 (vector-ref arg-8 1))) (let ((e-15 (vector-ref arg-8 2))) (let ((e-16 (vector-ref arg-8 3))) (let ((e-17 (vector-ref arg-8 4))) (vector 1 e-14 e-15 e-16 (DataC-45ListC-45Suffix-weakens (+ e-17 arg-9)))))))))))
(define TextC-45ParseC-45Core-case--prs-5596 (lambda (arg-7 arg-8 arg-9 arg-10 arg-13 arg-15) (case (vector-ref arg-15 0) ((1) (let ((e-6 (vector-ref arg-15 1))) (let ((e-7 (vector-ref arg-15 2))) (let ((e-8 (vector-ref arg-15 3))) (let ((e-9 (vector-ref arg-15 4))) (cond ((equal? e-9 0) (let ((sc2 (TextC-45ParseC-45Core-prs arg-7 e-6 arg-13 arg-10))) (case (vector-ref sc2 0) ((0) (let ((e-11 (vector-ref sc2 1))) (let ((e-10 (vector-ref sc2 2))) (vector 0 e-11 e-10)))) (else (let ((e-14 (vector-ref sc2 1))) (let ((e-15 (vector-ref sc2 2))) (let ((e-16 (vector-ref sc2 3))) (let ((e-17 (vector-ref sc2 4))) (vector 1 e-14 (TextC-45Bounds-app e-7 e-15) e-16 e-17)))))))))(else (let ((e-26 (- e-9 1))) (let ((sc1 (TextC-45ParseC-45Core-prs arg-7 e-6 1 e-8))) (case (vector-ref sc1 0) ((0) (let ((e-11 (vector-ref sc1 1))) (let ((e-10 (vector-ref sc1 2))) (vector 0 e-11 e-10)))) (else (let ((e-14 (vector-ref sc1 1))) (let ((e-15 (vector-ref sc1 2))) (let ((e-16 (vector-ref sc1 3))) (let ((e-17 (vector-ref sc1 4))) (vector 1 e-14 (TextC-45Bounds-app e-7 e-15) e-16 (+ e-17 (+ e-26 1)))))))))))))))))) (else (let ((e-16 (vector-ref arg-15 1))) (let ((e-17 (vector-ref arg-15 2))) (vector 0 e-16 e-17)))))))
(define TextC-45ParseC-45Core-case--prs-6059 (lambda (arg-6 arg-7 arg-8 arg-9 arg-12 arg-14) (case (vector-ref arg-14 0) ((1) (let ((e-6 (vector-ref arg-14 1))) (let ((e-7 (vector-ref arg-14 2))) (let ((e-8 (vector-ref arg-14 3))) (let ((e-9 (vector-ref arg-14 4))) (let ((sc1 (TextC-45ParseC-45Core-prs (arg-6) e-6 1 e-8))) (case (vector-ref sc1 0) ((0) (let ((e-11 (vector-ref sc1 1))) (let ((e-10 (vector-ref sc1 2))) (vector 0 e-11 e-10)))) (else (let ((e-14 (vector-ref sc1 1))) (let ((e-15 (vector-ref sc1 2))) (let ((e-16 (vector-ref sc1 3))) (let ((e-17 (vector-ref sc1 4))) (vector 1 e-14 (TextC-45Bounds-app e-7 e-15) e-16 (+ e-17 e-9)))))))))))))) (else (let ((e-16 (vector-ref arg-14 1))) (let ((e-17 (vector-ref arg-14 2))) (vector 0 e-16 e-17)))))))
(define TextC-45ParseC-45Core-case--prs-6318 (lambda (arg-6 arg-7 arg-8 arg-9 arg-12 arg-14) (case (vector-ref arg-14 0) ((1) (let ((e-6 (vector-ref arg-14 1))) (let ((e-7 (vector-ref arg-14 2))) (let ((e-8 (vector-ref arg-14 3))) (let ((e-9 (vector-ref arg-14 4))) (TextC-45ParseC-45Core-merge e-7 (TextC-45ParseC-45Core-succ (TextC-45ParseC-45Core-prs ((arg-6) (let ((e-1 (car e-7))) e-1)) e-6 1 e-8) e-9))))))) (else (let ((e-16 (vector-ref arg-14 1))) (let ((e-17 (vector-ref arg-14 2))) (vector 0 e-16 e-17)))))))
(define TextC-45ParseC-45Core-case--prs-6462 (lambda (arg-7 arg-8 arg-9 arg-10 arg-13 arg-15) (case (vector-ref arg-15 0) ((1) (let ((e-6 (vector-ref arg-15 1))) (let ((e-7 (vector-ref arg-15 2))) (let ((e-8 (vector-ref arg-15 3))) (let ((e-9 (vector-ref arg-15 4))) (cond ((equal? e-9 0) (TextC-45ParseC-45Core-merge e-7 (TextC-45ParseC-45Core-prs (arg-7 (let ((e-1 (car e-7))) e-1)) e-6 arg-13 arg-10)))(else (let ((e-24 (- e-9 1))) (TextC-45ParseC-45Core-merge e-7 (TextC-45ParseC-45Core-succ (TextC-45ParseC-45Core-prs (arg-7 (let ((e-1 (car e-7))) e-1)) e-6 1 e-8) (+ e-24 1))))))))))) (else (let ((e-16 (vector-ref arg-15 1))) (let ((e-17 (vector-ref arg-15 2))) (vector 0 e-16 e-17)))))))
(define TextC-45ParseC-45Core-case--prs-7344 (lambda (arg-5 arg-6 arg-7 arg-9 arg-11) (case (vector-ref arg-11 0) ((1) (let ((e-6 (vector-ref arg-11 1))) (let ((e-7 (vector-ref arg-11 2))) (let ((e-8 (vector-ref arg-11 3))) (let ((e-9 (vector-ref arg-11 4))) (vector 1 e-6 (cons e-7 (let ((e-2 (cdr e-7))) e-2)) e-8 e-9)))))) (else (let ((e-16 (vector-ref arg-11 1))) (let ((e-17 (vector-ref arg-11 2))) (vector 0 e-16 e-17)))))))
(define TextC-45ParseC-45Core-case--prs-7450 (lambda (arg-5 arg-6 arg-7 arg-9 arg-10) (case (vector-ref arg-10 0) ((0) (let ((e-7 (vector-ref arg-10 2))) (vector 0 0 e-7)))(else arg-10))))
(define TextC-45ParseC-45Core-prs (lambda (arg-5 arg-6 arg-7 arg-8) (case (vector-ref arg-5 0) ((0) (let ((e-5 (vector-ref arg-5 1))) (let ((sc1 ((e-5 arg-6) arg-8))) (case (vector-ref sc1 0) ((0) (let ((e-6 (vector-ref sc1 1))) (let ((e-7 (vector-ref sc1 2))) (vector 0 (cond ((equal? arg-7 1) 1) (else e-6)) e-7)))) (else (let ((e-14 (vector-ref sc1 1))) (let ((e-15 (vector-ref sc1 2))) (let ((e-16 (vector-ref sc1 3))) (let ((e-17 (vector-ref sc1 4))) (vector 1 e-14 e-15 e-16 e-17)))))))))) ((2) (let ((e-13 (vector-ref arg-5 1))) (let ((e-14 (vector-ref arg-5 2))) (TextC-45ParseC-45Core-case--prs-5596 e-14 e-13 arg-6 arg-8 arg-7 (TextC-45ParseC-45Core-prs e-13 arg-6 arg-7 arg-8))))) ((1) (let ((e-21 (vector-ref arg-5 1))) (let ((e-22 (vector-ref arg-5 2))) (TextC-45ParseC-45Core-case--prs-6059 e-22 e-21 arg-6 arg-8 arg-7 (TextC-45ParseC-45Core-prs e-21 arg-6 arg-7 arg-8))))) ((3) (let ((e-29 (vector-ref arg-5 1))) (let ((e-30 (vector-ref arg-5 2))) (TextC-45ParseC-45Core-case--prs-6318 e-30 e-29 arg-6 arg-8 arg-7 (TextC-45ParseC-45Core-prs e-29 arg-6 arg-7 arg-8))))) ((4) (let ((e-38 (vector-ref arg-5 1))) (let ((e-39 (vector-ref arg-5 2))) (TextC-45ParseC-45Core-case--prs-6462 e-39 e-38 arg-6 arg-8 arg-7 (TextC-45ParseC-45Core-prs e-38 arg-6 arg-7 arg-8))))) ((5) (let ((e-46 (vector-ref arg-5 1))) (let ((e-47 (vector-ref arg-5 2))) (let ((sc1 (TextC-45ParseC-45Core-prs e-46 arg-6 arg-7 arg-8))) (case (vector-ref sc1 0) ((1) (let ((e-6 (vector-ref sc1 1))) (let ((e-7 (vector-ref sc1 2))) (let ((e-8 (vector-ref sc1 3))) (let ((e-9 (vector-ref sc1 4))) (TextC-45ParseC-45Core-merge e-7 (TextC-45ParseC-45Core-succ (TextC-45ParseC-45Core-prs (e-47) e-6 1 e-8) e-9))))))) (else (let ((e-16 (vector-ref sc1 1))) (let ((e-17 (vector-ref sc1 2))) (vector 0 e-16 e-17))))))))) ((6) (let ((e-55 (vector-ref arg-5 1))) (let ((e-56 (vector-ref arg-5 2))) (let ((sc1 (TextC-45ParseC-45Core-prs e-55 arg-6 arg-7 arg-8))) (case (vector-ref sc1 0) ((1) (let ((e-6 (vector-ref sc1 1))) (let ((e-7 (vector-ref sc1 2))) (let ((e-8 (vector-ref sc1 3))) (let ((e-9 (vector-ref sc1 4))) (cond ((equal? e-9 0) (TextC-45ParseC-45Core-merge e-7 (TextC-45ParseC-45Core-prs e-56 e-6 arg-7 arg-8)))(else (let ((e-24 (- e-9 1))) (TextC-45ParseC-45Core-merge e-7 (TextC-45ParseC-45Core-succ (TextC-45ParseC-45Core-prs e-56 e-6 1 e-8) (+ e-24 1))))))))))) (else (let ((e-16 (vector-ref sc1 1))) (let ((e-17 (vector-ref sc1 2))) (vector 0 e-16 e-17))))))))) ((7) (let ((e-63 (vector-ref arg-5 1))) (let ((e-64 (vector-ref arg-5 2))) (let ((sc1 (TextC-45ParseC-45Core-prs e-63 arg-6 0 arg-8))) (case (vector-ref sc1 0) ((1) (let ((e-6 (vector-ref sc1 1))) (let ((e-7 (vector-ref sc1 2))) (let ((e-8 (vector-ref sc1 3))) (let ((e-9 (vector-ref sc1 4))) (vector 1 e-6 e-7 e-8 e-9)))))) (else (let ((e-16 (vector-ref sc1 1))) (let ((e-17 (vector-ref sc1 2))) (cond ((equal? e-16 1) (vector 0 1 e-17)) (else (let ((sc3 (TextC-45ParseC-45Core-prs (e-64) arg-6 0 arg-8))) (case (vector-ref sc3 0) ((1) (let ((e-6 (vector-ref sc3 1))) (let ((e-7 (vector-ref sc3 2))) (let ((e-8 (vector-ref sc3 3))) (let ((e-9 (vector-ref sc3 4))) (vector 1 e-6 e-7 e-8 e-9)))))) (else (let ((e-19 (vector-ref sc3 1))) (let ((e-18 (vector-ref sc3 2))) (cond ((equal? e-19 1) (vector 0 1 e-18)) (else (vector 0 arg-7 (DataC-45List1-C-43C-43 e-17 e-18))))))))))))))))))) ((8) (let ((e-70 (vector-ref arg-5 1))) (TextC-45ParseC-45Core-case--prs-7344 e-70 arg-6 arg-8 arg-7 (TextC-45ParseC-45Core-prs e-70 arg-6 arg-7 arg-8)))) (else (let ((e-76 (vector-ref arg-5 1))) (TextC-45ParseC-45Core-case--prs-7450 e-76 arg-6 arg-8 arg-7 (TextC-45ParseC-45Core-prs e-76 arg-6 arg-7 arg-8)))))))
(define TextC-45ParseC-45Core-parse (lambda (arg-5 arg-6 arg-7) (let ((sc0 (TextC-45ParseC-45Core-prs arg-5 arg-6 0 arg-7))) (case (vector-ref sc0 0) ((0) (let ((e-7 (vector-ref sc0 2))) (vector 0 e-7))) (else (let ((e-14 (vector-ref sc0 1))) (let ((e-15 (vector-ref sc0 2))) (let ((e-16 (vector-ref sc0 3))) (vector 1 (cons e-14 (cons (let ((e-1 (car e-15))) e-1) e-16)))))))))))
(define DataC-45List1-singleton (lambda (arg-1) (cons arg-1 '())))
(define TextC-45ParseC-45Core-C-60C-42C-62 (lambda (arg-6 ext-1 ext-0) (cond ((equal? arg-6 1) (vector 1 ext-1 ext-0)) (else (vector 2 ext-1 ext-0)))))
(define TextC-45ParseC-45Core-readHead (lambda (arg-4) (vector 0 (lambda (u--s) (lambda (u--cs) (if (null? u--cs) (vector 0 0 (cons (cons (vector 1 ) '()) '())) (let ((e-1 (car u--cs))) (let ((e-2 (cdr u--cs))) (let ((sc1 (arg-4 (let ((e-4 (car e-1))) e-4)))) (case (vector-ref sc1 0) ((1) (let ((e-3 (vector-ref sc1 1))) (vector 1 u--s (cons e-3 (let ((e-4 (cdr e-1))) e-4)) e-2 1))) (else (let ((e-5 (vector-ref sc1 1))) (vector 0 0 (cons (cons e-5 (let ((e-3 (cdr e-1))) e-3)) '()))))))))))))))
(define TextC-45ParseC-45Core-is (lambda (arg-3 arg-4) (TextC-45ParseC-45Core-readHead (lambda (u--h) (let ((sc0 (let ((e-1 (car arg-3))) ((e-1 arg-4) u--h)))) (cond ((equal? sc0 1) (vector 1 (vector 0 ))) (else (vector 0 (vector 2 (vector 1 arg-4))))))))))
(define MathExpr-lit (TextC-45ParseC-45Core-readHead (lambda (u--h) (case (vector-ref u--h 0) ((1) (let ((e-0 (vector-ref u--h 1))) (vector 1 e-0)))(else (vector 0 (vector 9 (vector 1 u--h))))))))
(define TextC-45ParseC-45Core-u--map_Functor_C-40C-40C-40C-40GrammarC-32C-36bC-41C-32C-36sC-41C-32C-36tC-41C-32C-36eC-41 (lambda (arg-6 arg-7) (vector 4 arg-7 (lambda (eta-0) (vector 0 (lambda (u--s) (lambda (u--ts) (vector 1 u--s (cons (arg-6 eta-0) '()) u--ts 0))))))))
(define MathExpr-div (lambda () (TextC-45ParseC-45Core-C-60C-42C-62 1 (TextC-45ParseC-45Core-u--map_Functor_C-40C-40C-40C-40GrammarC-32C-36bC-41C-32C-36sC-41C-32C-36tC-41C-32C-36eC-41 (lambda (eta-0) (lambda (eta-1) (vector 4 eta-0 eta-1))) MathExpr-lit) (lambda () (vector 4 (TextC-45ParseC-45Core-is csegen-37 (vector 0 #\/)) (lambda (_-4039) (MathExpr-value2)))))))
(define MathExpr-mul (lambda () (TextC-45ParseC-45Core-C-60C-42C-62 1 (TextC-45ParseC-45Core-u--map_Functor_C-40C-40C-40C-40GrammarC-32C-36bC-41C-32C-36sC-41C-32C-36tC-41C-32C-36eC-41 (lambda (eta-0) (lambda (eta-1) (vector 3 eta-0 eta-1))) MathExpr-lit) (lambda () (vector 4 (TextC-45ParseC-45Core-is csegen-37 (vector 0 #\*)) (lambda (_-4039) (MathExpr-value2)))))))
(define MathExpr-sub (lambda () (TextC-45ParseC-45Core-C-60C-42C-62 1 (TextC-45ParseC-45Core-u--map_Functor_C-40C-40C-40C-40GrammarC-32C-36bC-41C-32C-36sC-41C-32C-36tC-41C-32C-36eC-41 (lambda (eta-0) (lambda (eta-1) (vector 2 eta-0 eta-1))) MathExpr-lit) (lambda () (vector 4 (TextC-45ParseC-45Core-is csegen-37 (vector 0 #\-)) (lambda (_-4039) (MathExpr-value2)))))))
(define MathExpr-add2 (lambda () (TextC-45ParseC-45Core-C-60C-42C-62 1 (TextC-45ParseC-45Core-u--map_Functor_C-40C-40C-40C-40GrammarC-32C-36bC-41C-32C-36sC-41C-32C-36tC-41C-32C-36eC-41 (lambda (eta-0) (lambda (eta-1) (vector 1 eta-0 eta-1))) MathExpr-lit) (lambda () (vector 4 (TextC-45ParseC-45Core-is csegen-37 (vector 0 #\+)) (lambda (_-4039) (MathExpr-value2)))))))
(define MathExpr-sum (lambda () (vector 7 (MathExpr-add2) (lambda () (MathExpr-value2)))))
(define MathExpr-var (TextC-45ParseC-45Core-u--map_Functor_C-40C-40C-40C-40GrammarC-32C-36bC-41C-32C-36sC-41C-32C-36tC-41C-32C-36eC-41 (lambda (eta-0) (vector 5 eta-0)) (TextC-45ParseC-45Core-readHead (lambda (u--h) (let ((sc0 (case (vector-ref u--h 0) ((1) (let ((e-0 (vector-ref u--h 1))) (case (vector-ref e-0 0) ((5) (let ((e-1 (vector-ref e-0 1))) (box e-1)))(else '()))))(else '())))) (if (null? sc0) (vector 0 (vector 9 (vector 1 u--h))) (let ((e-1 (unbox sc0))) (vector 1 e-1))))))))
(define MathExpr-value2 (lambda () (vector 7 MathExpr-lit (lambda () (vector 7 (MathExpr-sub) (lambda () (vector 7 (MathExpr-sum) (lambda () (vector 7 (MathExpr-mul) (lambda () (vector 7 (MathExpr-div) (lambda () MathExpr-var))))))))))))
(define PreludeC-45TypesC-45SnocList-C-60C-62C-62 (lambda (arg-1 arg-2) (if (null? arg-1) arg-2 (let ((e-2 (car arg-1))) (let ((e-3 (cdr arg-1))) (PreludeC-45TypesC-45SnocList-C-60C-62C-62 e-2 (cons e-3 arg-2)))))))
(define PreludeC-45TypesC-45List-mapAppend (lambda (arg-2 arg-3 arg-4) (if (null? arg-4) (PreludeC-45TypesC-45SnocList-C-60C-62C-62 arg-2 '()) (let ((e-1 (car arg-4))) (let ((e-2 (cdr arg-4))) (PreludeC-45TypesC-45List-mapAppend (cons arg-2 (arg-3 e-1)) arg-3 e-2))))))
(define DataC-45List1-u--map_Functor_List1 (lambda (arg-2 arg-3) (let ((e-1 (car arg-3))) (let ((e-2 (cdr arg-3))) (cons (arg-2 e-1) (PreludeC-45TypesC-45List-mapAppend '() arg-2 e-2))))))
(define MathExpr-case--parse2-3101 (lambda (arg-0 arg-1) (case (vector-ref arg-1 0) ((0) (let ((e-2 (vector-ref arg-1 1))) (vector 0 (DataC-45List1-singleton (let ((sc1 (TextC-45Bounds-u--map_Functor_Bounded (lambda (eta-0) eta-0) e-2))) (let ((e-1 (car sc1))) (let ((e-3 (cdr sc1))) (cons (cons '() e-3) e-1)))))))) (else (let ((e-5 (vector-ref arg-1 1))) (let ((sc1 (TextC-45ParseC-45Core-parse (MathExpr-value2) (vector 0 ) e-5))) (case (vector-ref sc1 0) ((0) (let ((e-2 (vector-ref sc1 1))) (vector 0 (DataC-45List1-u--map_Functor_List1 (lambda (eta-0) (let ((e-1 (car eta-0))) (let ((e-3 (cdr eta-0))) (cons (cons '() e-3) e-1)))) e-2)))) (else (let ((e-6 (vector-ref sc1 1))) (let ((e-9 (cdr e-6))) (let ((e-12 (car e-9))) (let ((e-13 (cdr e-9))) (if (null? e-13) (vector 1 e-12) (let ((e-16 (car e-13))) (vector 0 (DataC-45List1-singleton (let ((sc5 (TextC-45Bounds-u--map_Functor_Bounded (lambda (eta-0) (vector 9 (vector 1 eta-0))) e-16))) (let ((e-1 (car sc5))) (let ((e-2 (cdr sc5))) (cons (cons '() e-2) e-1))))))))))))))))))))
(define MathExpr-parse2 (lambda (arg-0) (MathExpr-case--parse2-3101 arg-0 ((MathExpr-tokJSON2) arg-0))))
(define DataC-45String-n--3688-7697-u--unlinesC-39 (lambda (arg-0) (if (null? arg-0) '() (let ((e-2 (car arg-0))) (let ((e-3 (cdr arg-0))) (cons e-2 (cons "\u000a" (DataC-45String-n--3688-7697-u--unlinesC-39 e-3))))))))
(define DataC-45String-fastUnlines (lambda (ext-0) (PreludeC-45Types-fastConcat (DataC-45String-n--3688-7697-u--unlinesC-39 ext-0))))
(define DataC-45String-n--3821-7827-u--linesHelp (lambda (arg-0 arg-1 arg-2) (if (null? arg-1) (if (null? arg-2) '() (if (null? arg-2) (cons (PreludeC-45TypesC-45List-reverse arg-1) '()) (let ((e-2 (car arg-2))) (let ((e-3 (cdr arg-2))) (cond ((equal? e-2 (integer->char 10)) (cons (PreludeC-45TypesC-45List-reverse arg-1) (DataC-45String-n--3821-7827-u--linesHelp arg-0 '() e-3))) ((equal? e-2 (integer->char 13)) (if (null? e-3) (cons (PreludeC-45TypesC-45List-reverse arg-1) (DataC-45String-n--3821-7827-u--linesHelp arg-0 '() e-3)) (let ((e-5 (car e-3))) (let ((e-6 (cdr e-3))) (cond ((equal? e-5 (integer->char 10)) (cons (PreludeC-45TypesC-45List-reverse arg-1) (DataC-45String-n--3821-7827-u--linesHelp arg-0 '() e-6)))(else (cons (PreludeC-45TypesC-45List-reverse arg-1) (DataC-45String-n--3821-7827-u--linesHelp arg-0 '() e-3))))))))(else (DataC-45String-n--3821-7827-u--linesHelp arg-0 (cons e-2 arg-1) e-3))))))) (if (null? arg-2) (cons (PreludeC-45TypesC-45List-reverse arg-1) '()) (let ((e-2 (car arg-2))) (let ((e-3 (cdr arg-2))) (cond ((equal? e-2 (integer->char 10)) (cons (PreludeC-45TypesC-45List-reverse arg-1) (DataC-45String-n--3821-7827-u--linesHelp arg-0 '() e-3))) ((equal? e-2 (integer->char 13)) (if (null? e-3) (cons (PreludeC-45TypesC-45List-reverse arg-1) (DataC-45String-n--3821-7827-u--linesHelp arg-0 '() e-3)) (let ((e-5 (car e-3))) (let ((e-6 (cdr e-3))) (cond ((equal? e-5 (integer->char 10)) (cons (PreludeC-45TypesC-45List-reverse arg-1) (DataC-45String-n--3821-7827-u--linesHelp arg-0 '() e-6)))(else (cons (PreludeC-45TypesC-45List-reverse arg-1) (DataC-45String-n--3821-7827-u--linesHelp arg-0 '() e-3))))))))(else (DataC-45String-n--3821-7827-u--linesHelp arg-0 (cons e-2 arg-1) e-3)))))))))
(define DataC-45String-linesC-39 (lambda (arg-0) (DataC-45String-n--3821-7827-u--linesHelp arg-0 '() arg-0)))
(define DataC-45String-lines (lambda (arg-0) (PreludeC-45TypesC-45List-mapAppend '() (lambda (eta-0) (PreludeC-45Types-fastPack eta-0)) (DataC-45String-linesC-39 (PreludeC-45Types-fastUnpack arg-0)))))
(define PreludeC-45Types-listBindOnto (lambda (arg-2 arg-3 arg-4) (if (null? arg-4) (PreludeC-45TypesC-45List-reverse arg-3) (let ((e-2 (car arg-4))) (let ((e-3 (cdr arg-4))) (PreludeC-45Types-listBindOnto arg-2 (PreludeC-45TypesC-45List-reverseOnto arg-3 (arg-2 e-2)) e-3))))))
(define PreludeC-45Types-listBind (lambda (arg-2 arg-3) (PreludeC-45Types-listBindOnto arg-3 '() arg-2)))
(define DataC-45List-replicateTR (lambda (arg-1 arg-2 arg-3) (cond ((equal? arg-2 0) arg-1)(else (let ((e-0 (- arg-2 1))) (DataC-45List-replicateTR (cons arg-3 arg-1) e-0 arg-3))))))
(define DataC-45String-replicate (lambda (arg-0 arg-1) (PreludeC-45Types-fastPack (DataC-45List-replicateTR '() arg-0 arg-1))))
(define DataC-45String-indent (lambda (arg-0 arg-1) (string-append (DataC-45String-replicate arg-0 #\ ) arg-1)))
(define PreludeC-45TypesC-45String-length (lambda (arg-0) (PreludeC-45Types-prim__integerToNat (string-length arg-0))))
(define DataC-45String-padLeft (lambda (arg-0 arg-1 arg-2) (string-append (DataC-45String-replicate (PreludeC-45Types-prim__integerToNat (- arg-0 (PreludeC-45TypesC-45String-length arg-2))) arg-1) arg-2)))
(define PreludeC-45Show-u--showPrec_Show_Integer (lambda (ext-0 ext-1) (PreludeC-45Show-primNumShow (lambda (eta-0) (number->string eta-0)) ext-0 ext-1)))
(define PreludeC-45Show-u--show_Show_Integer (lambda (arg-0) (PreludeC-45Show-u--showPrec_Show_Integer (vector 0 ) arg-0)))
(define PreludeC-45Show-u--show_Show_Nat (lambda (arg-0) (PreludeC-45Show-u--show_Show_Integer arg-0)))
(define TextC-45FC-lineNumbers (lambda (arg-0 arg-1 arg-2 arg-3) (if (null? arg-3) arg-0 (let ((e-2 (car arg-3))) (let ((e-3 (cdr arg-3))) (let ((u--k (+ arg-2 1))) (let ((u--pre (DataC-45String-padLeft arg-1 #\0 (PreludeC-45Show-u--show_Show_Nat u--k)))) (TextC-45FC-lineNumbers (cons arg-0 (PreludeC-45Types-u--foldMap_Foldable_List csegen-7 (lambda (eta-0) eta-0) (cons " " (cons u--pre (cons " | " (cons e-2 '())))))) arg-1 u--k e-3))))))))
(define DataC-45List-drop (lambda (arg-1 arg-2) (cond ((equal? arg-1 0) arg-2)(else (let ((e-0 (- arg-1 1))) (if (null? arg-2) '() (let ((e-4 (cdr arg-2))) (DataC-45List-drop e-0 e-4))))))))
(define DataC-45List-take (lambda (arg-1 arg-2) (cond ((equal? arg-1 0) '())(else (let ((e-0 (- arg-1 1))) (if (null? arg-2) '() (let ((e-2 (car arg-2))) (let ((e-3 (cdr arg-2))) (cons e-2 (DataC-45List-take e-0 e-3))))))))))
(define TextC-45FC-range (lambda (arg-1 arg-2 ext-0) (DataC-45List-take (+ (PreludeC-45Types-prim__integerToNat (- arg-2 arg-1)) 1) (DataC-45List-drop arg-1 ext-0))))
(define TextC-45Bounds-u--interpolate_Interpolation_Position (lambda (arg-0) (let ((e-0 (car arg-0))) (let ((e-1 (cdr arg-0))) (string-append (PreludeC-45Show-u--show_Show_Nat (+ e-0 1)) (string-append ":" (PreludeC-45Show-u--show_Show_Nat (+ e-1 1))))))))
(define TextC-45Bounds-u--interpolate_Interpolation_Bounds (lambda (arg-0) (if (null? arg-0) "" (let ((e-0 (car arg-0))) (let ((e-1 (cdr arg-0))) (PreludeC-45Types-u--foldMap_Foldable_List csegen-7 (lambda (eta-0) eta-0) (cons (TextC-45Bounds-u--interpolate_Interpolation_Position e-0) (cons "--" (cons (TextC-45Bounds-u--interpolate_Interpolation_Position e-1) '())))))))))
(define TextC-45FC-u--interpolate_Interpolation_Origin (lambda (arg-0) (if (null? arg-0) "virtual" (let ((e-0 (unbox arg-0))) e-0))))
(define TextC-45FC-u--interpolate_Interpolation_FileContext (lambda (arg-0) (let ((e-0 (car arg-0))) (let ((e-1 (cdr arg-0))) (if (null? e-1) (TextC-45FC-u--interpolate_Interpolation_Origin e-0) (PreludeC-45Types-u--foldMap_Foldable_List csegen-7 (lambda (eta-0) eta-0) (cons (TextC-45FC-u--interpolate_Interpolation_Origin e-0) (cons ": " (cons (TextC-45Bounds-u--interpolate_Interpolation_Bounds e-1) '())))))))))
(define PreludeC-45Types-u--C-62_Ord_Nat (lambda (arg-0 arg-1) (PreludeC-45EqOrd-u--C-61C-61_Eq_Ordering (PreludeC-45EqOrd-u--compare_Ord_Integer arg-0 arg-1) 2)))
(define PreludeC-45Types-u--max_Ord_Nat (lambda (arg-0 arg-1) (let ((sc0 (PreludeC-45Types-u--C-62_Ord_Nat arg-0 arg-1))) (cond ((equal? sc0 1) arg-0) (else arg-1)))))
(define PreludeC-45Types-u--C-60_Ord_Nat (lambda (arg-0 arg-1) (PreludeC-45EqOrd-u--C-61C-61_Eq_Ordering (PreludeC-45EqOrd-u--compare_Ord_Integer arg-0 arg-1) 0)))
(define PreludeC-45Types-u--min_Ord_Nat (lambda (arg-0 arg-1) (let ((sc0 (PreludeC-45Types-u--C-60_Ord_Nat arg-0 arg-1))) (cond ((equal? sc0 1) arg-0) (else arg-1)))))
(define TextC-45FC-case--printFC-7167 (lambda (arg-0 arg-1 arg-2) (if (null? arg-2) '() (let ((e-0 (car arg-2))) (let ((e-1 (cdr arg-2))) (let ((e-2 (car e-0))) (let ((e-3 (cdr e-0))) (let ((e-4 (car e-1))) (let ((e-5 (cdr e-1))) (let ((u--nsize (PreludeC-45TypesC-45String-length (PreludeC-45Show-u--show_Show_Nat (+ e-4 1))))) (let ((u--head (PreludeC-45Types-u--foldMap_Foldable_List csegen-7 (lambda (eta-0) eta-0) (cons (TextC-45FC-u--interpolate_Interpolation_FileContext arg-1) '())))) (let ((sc3 (or (and (= e-2 e-4) 1) 0))) (cond ((equal? sc3 0) (PreludeC-45TypesC-45SnocList-C-60C-62C-62 (TextC-45FC-lineNumbers (cons (cons '() "") u--head) u--nsize e-2 (TextC-45FC-range e-2 (PreludeC-45Types-u--min_Ord_Nat e-4 (+ e-2 5)) arg-0)) '())) (else (let ((u--cemph (PreludeC-45Types-u--max_Ord_Nat 1 (PreludeC-45Types-prim__integerToNat (- e-5 e-3))))) (let ((u--emph (DataC-45String-indent (+ (+ u--nsize e-3) 4) (DataC-45String-replicate u--cemph #\^)))) (let ((u--fr (PreludeC-45Types-prim__integerToNat (- e-4 4)))) (PreludeC-45TypesC-45SnocList-C-60C-62C-62 (TextC-45FC-lineNumbers (cons (cons '() "") u--head) u--nsize u--fr (TextC-45FC-range u--fr e-4 arg-0)) (cons u--emph '())))))))))))))))))))
(define TextC-45FC-printFC (lambda (arg-0 arg-1) (TextC-45FC-case--printFC-7167 arg-1 arg-0 (let ((e-1 (cdr arg-0))) e-1))))
(define TextC-45ParseError-printPair (lambda (arg-1 arg-2 arg-3) (let ((e-2 (car arg-3))) (let ((e-3 (cdr arg-3))) (cons (PreludeC-45Types-u--foldMap_Foldable_List csegen-7 (lambda (eta-0) eta-0) (cons "Error: " (cons (arg-1 e-3) '()))) (TextC-45FC-printFC e-2 arg-2))))))
(define TextC-45ParseError-printParseErrors (lambda (arg-2 arg-3 arg-4 arg-5) (let ((u--ls (DataC-45String-lines arg-4))) (DataC-45String-fastUnlines (PreludeC-45Types-listBind (let ((e-5 (vector-ref arg-2 4))) ((e-5 'erased) arg-5)) (lambda (eta-0) (TextC-45ParseError-printPair arg-3 u--ls eta-0)))))))
(define DataC-45List1-u--foldMap_Foldable_List1 (lambda (arg-2 arg-3 arg-4) (let ((e-1 (car arg-4))) (let ((e-2 (cdr arg-4))) (let ((e-4 (car arg-2))) ((e-4 (arg-3 e-1)) (PreludeC-45Types-u--foldMap_Foldable_List arg-2 arg-3 e-2)))))))
(define PreludeC-45Basics-flip (lambda (arg-3 ext-0 ext-1) ((arg-3 ext-1) ext-0)))
(define DataC-45List1-u--foldl_Foldable_List1 (lambda (arg-2 arg-3 arg-4) (let ((e-1 (car arg-4))) (let ((e-2 (cdr arg-4))) (PreludeC-45Types-u--foldl_Foldable_List arg-2 ((arg-2 arg-3) e-1) e-2)))))
(define DataC-45List1-u--foldlM_Foldable_List1 (lambda (arg-3 arg-4 arg-5 ext-0) (DataC-45List1-u--foldl_Foldable_List1 (lambda (u--ma) (lambda (u--b) (let ((e-2 (vector-ref arg-3 1))) ((((e-2 'erased) 'erased) u--ma) (lambda (eta-0) (PreludeC-45Basics-flip arg-4 u--b eta-0)))))) (let ((e-1 (vector-ref arg-3 0))) (let ((e-5 (vector-ref e-1 1))) ((e-5 'erased) arg-5))) ext-0)))
(define PreludeC-45Types-u--foldr_Foldable_List (lambda (arg-2 arg-3 arg-4) (if (null? arg-4) arg-3 (let ((e-2 (car arg-4))) (let ((e-3 (cdr arg-4))) ((arg-2 e-2) (PreludeC-45Types-u--foldr_Foldable_List arg-2 arg-3 e-3)))))))
(define DataC-45List1-u--foldr_Foldable_List1 (lambda (arg-2 arg-3 arg-4) (let ((e-1 (car arg-4))) (let ((e-2 (cdr arg-4))) ((arg-2 e-1) (PreludeC-45Types-u--foldr_Foldable_List arg-2 arg-3 e-2))))))
(define TextC-45ParseError-u--interpolate_Interpolation_DigitType (lambda (arg-0) (cond ((equal? arg-0 0) "a binary digit ('0' or '1')") ((equal? arg-0 1) "an octal digit ('0' to '7')") ((equal? arg-0 2) "a decimal digit ('0' to '9')") (else "a hexadecimal digit ('0' to '9' or 'a' to 'f')"))))
(define TextC-45ParseError-u--interpolate_Interpolation_CharClass (lambda (arg-0) (case (vector-ref arg-0 0) ((0) "a space character") ((1) (let ((e-0 (vector-ref arg-0 1))) (TextC-45ParseError-u--interpolate_Interpolation_DigitType e-0))) ((2) "an upper-case letter") ((3) "a lower-case letter") ((4) "a letter ('a' to 'z' or 'A' to 'Z')") (else "a letter or a digit"))))
(define TextC-45ParseError-u--interpolate_Interpolation_C-40C-40ParseErrorC-32C-36tC-41C-32C-36eC-41 (lambda (arg-2 arg-3 arg-4) (case (vector-ref arg-4 0) ((1) "Unexpected end of input") ((2) (let ((e-4 (vector-ref arg-4 1))) (PreludeC-45Types-u--foldMap_Foldable_List csegen-7 (lambda (eta-0) eta-0) (cons "Expected " (cons (PreludeC-45Types-either (lambda () (lambda (eta-0) eta-0)) (lambda () (lambda (eta-0) (arg-2 eta-0))) e-4) '()))))) ((3) (let ((e-7 (vector-ref arg-4 1))) (PreludeC-45Types-u--foldMap_Foldable_List csegen-7 (lambda (eta-0) eta-0) (cons "Expected " (cons (TextC-45ParseError-u--interpolate_Interpolation_CharClass e-7) '()))))) ((4) "Expected end of input") ((5) (let ((e-12 (vector-ref arg-4 1))) (PreludeC-45Types-u--foldMap_Foldable_List csegen-7 (lambda (eta-0) eta-0) (cons "Invalid control character: " (cons (PreludeC-45Show-u--show_Show_Char e-12) '()))))) ((6) "Invalid escape sequence") ((7) (let ((e-17 (vector-ref arg-4 1))) (PreludeC-45Types-u--foldMap_Foldable_List csegen-7 (lambda (eta-0) eta-0) (cons "Value out of bounds: " (cons (PreludeC-45Types-either (lambda () (lambda (eta-0) eta-0)) (lambda () (lambda (eta-0) (arg-2 eta-0))) e-17) '()))))) ((8) (let ((e-20 (vector-ref arg-4 1))) (PreludeC-45Types-u--foldMap_Foldable_List csegen-7 (lambda (eta-0) eta-0) (cons "Unclosed " (cons (PreludeC-45Types-either (lambda () (lambda (eta-0) eta-0)) (lambda () (lambda (eta-0) (arg-2 eta-0))) e-20) '()))))) ((9) (let ((e-23 (vector-ref arg-4 1))) (PreludeC-45Types-u--foldMap_Foldable_List csegen-7 (lambda (eta-0) eta-0) (cons "Unexpected " (cons (PreludeC-45Types-either (lambda () (lambda (eta-0) eta-0)) (lambda () (lambda (eta-0) (arg-2 eta-0))) e-23) '()))))) ((10) (let ((e-26 (vector-ref arg-4 1))) (PreludeC-45Types-u--foldMap_Foldable_List csegen-7 (lambda (eta-0) eta-0) (cons "Unknown or invalid token: " (cons (PreludeC-45Types-either (lambda () (lambda (eta-0) eta-0)) (lambda () (lambda (eta-0) (arg-2 eta-0))) e-26) '()))))) (else (let ((e-29 (vector-ref arg-4 1))) (arg-3 e-29))))))
(define MathExpr-u--interpolate_Interpolation_JSErr (lambda (arg-0) "Expected string literal"))
(define MathExpr-u--interpolate_Interpolation_JSToken (lambda (arg-0) (case (vector-ref arg-0 0) ((0) (let ((e-0 (vector-ref arg-0 1))) (PreludeC-45Show-u--show_Show_Char e-0))) ((1) (let ((e-1 (vector-ref arg-0 1))) (PreludeC-45Types-u--foldMap_Foldable_List csegen-7 (lambda (eta-0) eta-0) (cons "'" (cons (let ((sc1 (csegen-9))) (let ((e-3 (car sc1))) (e-3 e-1))) (cons "'" '())))))) (else "<spaces>"))))
(define MathExpr-testParse2 (lambda (arg-0 ext-0) (PreludeC-45IO-prim__putStr (string-append (PreludeC-45Types-either (lambda () (lambda (eta-0) (TextC-45ParseError-printParseErrors (vector (lambda (u--acc) (lambda (u--elem) (lambda (u--func) (lambda (u--init) (lambda (u--input) (DataC-45List1-u--foldr_Foldable_List1 u--func u--init u--input)))))) (lambda (u--elem) (lambda (u--acc) (lambda (u--func) (lambda (u--init) (lambda (u--input) (DataC-45List1-u--foldl_Foldable_List1 u--func u--init u--input)))))) (lambda (u--elem) (lambda (arg-10773) 0)) (lambda (u--elem) (lambda (u--acc) (lambda (u--m) (lambda (i_con-0) (lambda (u--funcM) (lambda (u--init) (lambda (u--input) (DataC-45List1-u--foldlM_Foldable_List1 i_con-0 u--funcM u--init u--input)))))))) (lambda (u--elem) (lambda (arg-10802) (DataC-45List1-forget arg-10802))) (lambda (u--a) (lambda (u--m) (lambda (i_con-0) (lambda (u--f) (lambda (arg-10816) (DataC-45List1-u--foldMap_Foldable_List1 i_con-0 u--f arg-10816))))))) (lambda (eta-1) (TextC-45ParseError-u--interpolate_Interpolation_C-40C-40ParseErrorC-32C-36tC-41C-32C-36eC-41 (lambda (arg-823) (MathExpr-u--interpolate_Interpolation_JSToken arg-823)) (lambda (arg-823) (MathExpr-u--interpolate_Interpolation_JSErr arg-823)) eta-1)) arg-0 eta-0))) (lambda () (lambda (eta-0) (let ((sc0 (csegen-9))) (let ((e-1 (car sc0))) (e-1 eta-0))))) (MathExpr-parse2 arg-0)) "\u000a") ext-0)))
(define PreludeC-45Show-n--3219-12514-u--showC-39 (lambda (arg-1 arg-2 arg-3 arg-4) (if (null? arg-4) arg-3 (let ((e-2 (car arg-4))) (let ((e-3 (cdr arg-4))) (if (null? e-3) (string-append arg-3 (let ((e-1 (car arg-1))) (e-1 e-2))) (PreludeC-45Show-n--3219-12514-u--showC-39 arg-1 arg-2 (string-append arg-3 (string-append (let ((e-1 (car arg-1))) (e-1 e-2)) ", ")) e-3)))))))
(define PreludeC-45Show-u--show_Show_C-40ListC-32C-36aC-41 (lambda (arg-1 arg-2) (string-append "[" (string-append (PreludeC-45Show-n--3219-12514-u--showC-39 arg-1 arg-2 "" arg-2) "]"))))
(define MathExpr-runTestCases (lambda (arg-0 ext-0) (if (null? arg-0) (PreludeC-45IO-prim__putStr "All test cases passed!\u000a" ext-0) (let ((e-2 (car arg-0))) (let ((e-3 (cdr arg-0))) (let ((act-1 (PreludeC-45IO-prim__putStr (string-append (string-append "Running test case: " (PreludeC-45Show-u--show_Show_C-40ListC-32C-36aC-41 csegen-48 e-2)) "\u000a") ext-0))) (let ((act-2 (MathExpr-testParse2 (PreludeC-45Types-u--foldMap_Foldable_List csegen-7 (lambda (eta-0) (let ((sc1 csegen-48)) (let ((e-1 (car sc1))) (e-1 eta-0)))) e-2) ext-0))) (let ((act-3 (PreludeC-45IO-prim__putStr "\u000a" ext-0))) (MathExpr-runTestCases e-3 ext-0)))))))))
(define MathMLExamples-sqrtExample (vector 2 (vector 0 (cons (vector 10 "\u221a") (cons (vector 0 (cons (vector 10 "(") (cons (vector 0 (cons (vector 11 "x") (cons (vector 10 "+") (cons (vector 12 "1") '())))) (cons (vector 10 ")") '())))) '())))))
(define MathMLExamples-subExample (vector 4 (vector 11 "a") (vector 12 "1")))
(define MathMLExamples-supExample (vector 5 (vector 11 "x") (vector 12 "2")))
(define MathExpr-testCases (cons (cons (vector 0 #\+) '()) '()))
(define Main-main (lambda (ext-0) (let ((act-1 ((Main-checkPrettyPrint MathMLExamples-fracExample "<mfrac><mn>1</mn><mn>2</mn></mfrac>") ext-0))) (let ((act-2 ((Main-checkPrettyPrint MathMLExamples-sqrtExample "<msqrt><mrow><mo>\u221a</mo><mrow><mo>(</mo><mrow><mi>x</mi><mo>+</mo><mn>1</mn></mrow><mo>)</mo></mrow></mrow></msqrt>") ext-0))) (let ((act-3 ((Main-checkPrettyPrint MathMLExamples-subExample "<msub><mi>a</mi><mn>1</mn></msub>") ext-0))) (let ((act-4 ((Main-checkPrettyPrint MathMLExamples-supExample "<msup><mi>x</mi><mn>2</mn></msup>") ext-0))) (let ((act-5 ((Main-checkPrettyPrint MathMLExamples-fracSupExample "<mfrac><msup><mi>a</mi><mn>2</mn></msup><msup><mi>b</mi><mn>3</mn></msup></mfrac>") ext-0))) (MathExpr-runTestCases MathExpr-testCases ext-0))))))))
(define PreludeC-45EqOrd-compareInteger (lambda (ext-0 ext-1) (PreludeC-45EqOrd-u--compare_Ord_Integer ext-0 ext-1)))
(define PrimIO-unsafeCreateWorld (lambda (arg-1) (arg-1 #f)))
(define PrimIO-unsafePerformIO (lambda (arg-1) (PrimIO-unsafeCreateWorld (lambda (u--w) (let ((eff-0 (arg-1 u--w))) eff-0)))))
(void (PrimIO-unsafePerformIO (lambda (eta-0) (Main-main eta-0))))
)
(collect-garbage)